<pre class='metadata'>
Title: A Unified Futures Proposal for C++
Abstract: Proposed composable future concepts that interoperate with executors.
Shortname: P1054
URL: wg21.link/P1054
Revision: 0
Audience: SG1
Status: D
Group: WG21
!Source: <a href="https://github.com/executors/futures/blob/master/futures.bs">github.com/executors/futures/blob/master/futures.bs</a>
No Abstract: yes
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Editor: Lee Howes, Facebook, lwh@fb.com
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: David S. Hollman, Sandia National Labs, dshollm@sandia.gov
</pre>

<!-- Keep this alphabetical by last name -->

Contributors:

* Marshall Cline
* Micha≈Ç   Dominiak
* Carter   Edwards
* Jay      Feldblum
* Andrii   Grynenko
* Jared    Hoberock
* Hartmut  Kaiser
* Chris    Kohlhoff
* Chris    Mysen
* Eric     Niebler
* Sean     Parent
* Cory     Perry
* Felix    Petriconi
* Kirk     Shoop
* Mathias  Stearn


Introduction {#intro}
=====================

This paper introduces a hiearchry of concepts for future types that are designed to:

* *Interoperate With Executors:* The concepts should require the functionality needed by [executors](https://wg21.link/P0443).
* *Compose With Each Other:* The concepts should require the types to be composable.
* *Stay Skinny:* The concepts should require absolutely nothing else so that it is not burdensome to write future types.

There are five concepts introduces in this paper:

* `FutureContinuation`, invocable objects that are called with the value or exception of a future as an argument.
* `SemiFuture`, which can be bound to an executor, an operation which produces a `ContinuableFuture` (`f = sf.via(exec)`).
* `ContinuableFuture`, which refine `SemiFuture` and can have one `FutureContinuation` attached to them (`f.then(c)`), which is executed on the future's associated executor when the future becomes ready.
* `SharedFuture`, which refine `ContinuableFuture` and can have multiple `FutureContinuation`s attached to them.
* `Promise`, which are associated with a future and make the future ready with either a value or an exception.

Or, described another way:

```
template <typename T>
struct FutureContinuation
{
  // At least one of these two overloads exists:
  auto operator()(T value);
  auto operator()(exception_arg_t, exception_ptr exception);
};

template <typename T>
struct SemiFuture
{
  template <typename Executor>
  ContinuableFuture<Executor, T> via(Executor&& exec) &&;
};

template <typename Executor, typename T>
struct ContinuableFuture
{
  template <typename Executor>
  ContinuableFuture<Executor, T> via(Executor&& exec) &&;

  template <typename Continuation>
  ContinuableFuture<Executor, auto> then(Continuation&& c) &&;
};

template <typename T>
struct SharedFuture
{
  template <typename Executor>
  ContinuableFuture<Executor, auto> via(Executor&& exec);

  template <typename Continuation>
  SharedFuture<Executor, auto> then(Continuation&& c);
};

template <typename T>
struct Promise
{
  void set_value(T value) &&;
  void set_exception(exception_ptr exception) &&;
};
```

The model of `SemiFuture` and `.via` gives us control of the transfer of
execution ownership between executors. In a world where we can chain work on
futures, using `.then` or a similar mechanism, we always open the question of
where that work runs. The answer, as proposed by
[P0443](https://wg21.link/P0443) and the related work is to use executors.
One problem that comes up in this model is how an API can control how its
callers chain work on futures that the API returns, without enqueuing more
work on the API's executor.

There are various mechanisms used in practice to enforce this:
 * Creating an intermediate executor as a handover type
 * Taking an executor as a parameter of the API

In [p0783](https://wg21.link/P0783) and [p0904](https://wg21.link/P0904) the
`SemiFuture` and `via` design was proposed as a mechanism to achieve this.
An API may return a handle to its work, a future in the most abstract sense,
that does not provide a means to chain more work. This future will complete on
whatever executor that API was using. This returned future satisfies the
`SemiFuture` concept, and the caller is hence aware that to make use of it he
must attach an executor, using `.via`, to transition from the API's control into
the caller's control.

From that point on, the caller can use the future as necessary, safely enqueuing
work onto a known executor, and protecting the API from misuse.

As a simple example:
```
std::standard_semi_future<DataType> async_api() {
  auto f = doAsyncWork();
  return f.then([](auto&& val){return deserialize(val);});
}

void caller() {
  LocalExecutor e;
  auto sf = async_api();
  auto f = sf.via(e);
  f.then([](DataType&& data){
    std::cout << "Name: " << data.name() << "\n";
  });
}
```

There is a strict separation of control here between `caller` and `async_api`.

**TODO: Explain future model.**

**TODO: Explain cancellation.**

**TODO: Explain how we avoid invalid states via rvalue ref qualifying consuming methods.**

The Error Model
--------------------

In the example below, let `f` and `g` be `ContinuableFuture`s and let `c` be a `FutureContinuation`.

```
g = f.then(c);
```

When `f` is fulfilled:

* If `f` has a value `val`:
  * If `c(val)` is well-formed, it is called and the future `g` is fulfilled with the result or any exception thrown from the evaluation.
  * Otherwise, the future `g`  is fulfilled with the value `val` (this is known as <dfn>future value propagation</dfn>).
* If `f` fails with error `exc`:
  * If `c(exception_arg, exc)` is well-formed, it is called and the future `g` is fulfilled with the result or any exception thrown from the evaluation.
  * Otherwise, the future `g` is fulfilled with the exception `exc` (this is known as <dfn>future exception propagation</dfn>).

Note that if both overloads are defined, `is_same_v<decltype(G(exception_arg, err)), decltype(G(val))>` shall be true.

FAQ
---

**Q: Where is `.get` and `.wait`?**

*A:*
Remember, the future concepts in this paper are intended to express the minimal requirements for executors interoperation and composition.
Executors do not require a blocking interface, and futures do not require a blocking interface to compose.
This paper proposes the addition of the free functions `std::this_thread::future_wait` and `std::this_thread::future_get`.
These functions will block on any `SemiFuture` type, and are suitable for use within `std::thread` execution agents.
Some individuals may feel that blocking interfaces are more fundamental for futures than continuation chaining interfaces - some may desire to not provide continuation chaining interfaces at all.
We believe that this is a perfectly valid design; however, such non-continuable futures are outside of the scope of this work.

* If you want to write a future that only has blocking interfaces and doesn't support continuations, that's fine! But that type of future cannot interoperate with executors.
* If you want to write a future that only doesn't have blocking interfaces and does support continuations, that's fine! That type of future can interoperate with executors, so you should conform to the proposed concepts.
* If you want to write a future that has blocking interfaces and supports continuations, that's fine! That type of future can interoperate with executors, so you should conform to the proposed concepts.

Related Work
------------

This work is unification of prior papers written individually by the authors:

* [P0701r0](https://wg21.link/P0701r0)
* [P0701r1](https://wg21.link/P0701r1)
* [P0783r0](https://wg21.link/P0783r0)
* [P0904r0](https://wg21.link/P0904r0)

Proposed New Wording
====================

Future/Promise Model
---------------------

<!-- Based on [futures.state] -->

#.  A <dfn>future</dfn> is an object that executes, on a executor, <dfn>continuations</dfn> that are passed an <dfn>asynchronous result</dfn> as a parameter.

  * A <dfn>unique future</dfn> moves from the [=asynchronous result=] and can have at most one [=continuation=] attached.
  * A <dfn>shared future</dfn> copies from the [=asynchronous result=] and can have one or more [=continuations=] attached.

#.  A <dfn>promise</dfn> is an object that produces an [=asynchronous result=] and is associated with a [=future=]. [ *Note:* Although a [=promise=] is associated with one [=future=], multipl
#. The status of a [=future=]:

  * Is either <dfn>ready</dfn>, <dfn>not ready</dfn>, or <dfn>invalid</dfn>.
  * Shall be [=ready=] if and only if the [=future promise pairs=] [=content=] holds a value or an exception ready for retrieval.

#.  An <dfn>asynchronous result</dfn> is either a value or an exception. The [=result=] is created by the [=promise=] and accessed by the [=future=].

#.  A [=future=] may optionally have a <dfn>cancellation notifier</dfn>, which is a nullary <a href="eel.is/c++draft/func.def">callable object</a>.

#.  When a [=future=] is <dfn data-lt="cancellation|cancel|cancels|cancelled">cancelled</dfn>:

  * If the [=future=] has a [=cancellation notifier=], it is called in the calling thread.
  * Then, the [=future's=] status is set to [=invalid=].

#.  When a [=continuation=] is <dfn data-lt="attachment|attach|attaches|attached">attached</dfn> to a [=future=]:

  * First, the [=status=] of its [=future=] is checked.
  * Then,
    * If the [=status=] is [=ready=] or [=not ready=]:
      * The [=continuation=] is enqueued for execution pending readiness of [=future=] on the [=future's=] executor, with the [=asynchronous result=] as its parameter.
      * Finally, if the [=future=] is a [=unique future=], the status is set to [=invalid=].
    * If the [=status=] is [=invalid=], the behavior is unspecified.

#.  When a [=promise=] <dfn data-lt="fulfillment|fulfill|fulfills|fulfilled">fulfills</dfn> its associated [=future=] with a value or error, if the lifetime of the [=future=] has not ended:

  * First, the [=status=] of its [=future=] is checked.
  * Then,
    * If the [=status=] is [=not ready=]:
      * If the [=future=] is a [=unique future=], the status is set to [=invalid=]. Otherwise, the [=status=] is set to [=ready=]
      * Finally, any execution agents that are blocking until the [=status=] is [=ready=] are unblocked.
    * If the [=status=] is [=ready=] or [=invalid=], the behavior is unspecified.

If the lifetime of the [=future=] has ended, [=fulfillment=] has no effect.

#. [=Fulfillment=] of a [=future=] synchronizes with execution of [=continuations=] that were enqueued for execution by that [=future=].

#. The lifetime of the [=continuations=] and the [=asynchronus result=] passed to the [=continuations=] shall last until execution of the [=continuations=] completes.
      [ *Note:* The [=future=] may move (if it is a [=unique future=]) or copy (if it is a [=shared future=]) from the result into a new object to ensure this behavior. - *End Note* ]
      [ *Note:* The [=future=] may move from [=continuations=] into new object to ensure this behavior. - *End Note* ]

#.  The lifetime of the [=continuations=] and the [=asynchronous result=] passed to the [=continuations=] shall last until execution of the [=continuations=] completes.
      [ *Note:* The [=promise=] may move or copy (if the result is `CopyConstructible`) from the result into a new object to ensure this behavior. - *End Note* ]
      [ *Note:* The [=promise=] may move from continuations into new object to ensure this behavior. - *End Note* ]

#.  Upon destruction of a [=promise=]:

  * First, the [=promise=] checks the [=status=] of its [=future=].
  * Then, if the [=status=] is [=not ready=], the [=promise=] shall be [=fulfilled=].

#.  Setting the [=status=] of a [=future=] <a href="http://eel.is/c++draft/intro.races#def:synchronize_with">synchronizes with</a> operations that check the [=future=]'s status.

#.  Operations that modify the set of continuations stored in a [=future=] <a href="http://eel.is/c++draft/intro.races#def:synchronize_with">synchronize with</a> each other.

#.  Successful [=fulfillment=] of a [=future=] <a href="http://eel.is/c++draft/intro.races#def:synchronize_with">synchronizes with</a> [=attachment=] of [=continuations=] to that future.

#.  Successful [=attachment=] of a [=continuation=] to a [=future=] <a href="http://eel.is/c++draft/intro.races#def:synchronize_with">synchronizes with</a> [=fulfillment=] of the promise [=associated=] with that [=future=].

#.  If a [=future=] has a [=cancellation notifier=], successful [=fulfillment=] of it's associated [=promise=] <a href="http://eel.is/c++draft/intro.races#def:synchronize_with">synchronizes with</a> [=cancellation=] of the [=future=].

`FutureContinuation` Requirements
---------------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

```
namespace std {

struct exception_arg_t { explicit exception_arg_t() = default; };

inline constexpr exception_arg_t exception_arg{};

template <typename F, typename T>
  struct is_future_value_continuation;

template <typename F, typename T>
  inline constexpr bool is_future_value_continuation_v
    = is_future_value_continuation<F, T>::value;

template <typename F>
  struct is_future_exception_continuation;

template <typename F>
  inline constexpr bool is_future_exception_continuation_v
    = is_future_exception_continuation<F>::value;

template <typename F, typename T>
  struct is_future_continuation;

template <typename F, typename T>
  inline constexpr bool is_future_continuation_v
    = is_future_continuation<F, T>::value;

}
```

1.  A <dfn>future continuation</dfn> is a <a href="eel.is/c++draft/func.def">callable object</a> that consumes the value of a [=future=].

<!-- Based on [optional.nullopt] p1 -->
2. The struct `exception_arg_t` is an empty structure type used as a unique type to disambiguate `FutureContinuation` overloads that are called when a [=future=] holds an exception from `FutureContinuation` overloads that are called when a [=future=] holds a value.

<!-- Based on [meta.rel] -->
3.  This sub-clause contains templates that may be used to determine at compile time whether a type meets the requirements of [=future continuations=] for a particular [=future=] value type. Each of these templates is a <a href="http://eel.is/c++draft/meta.rqmts#def:BinaryTypeTraith">`BinaryTypeTrait`</a> with a base characteristic of `true_type` if the corresponding condition is true, and `false_type` otherwise.
4.  A `FutureContinuation` type shall meet the `MoveConstructible` requirements and the requirements described in the Tables below.

<center>

**Type Property Queries**

<table border=1>
<tr>
  <th>Template</th>
  <th>Condition</th>
  <th>Preconditions</th>
</tr>
<tr>
  <td>
```
template <typename F, typename T>
struct is_future_value_continuation;
```
  </td>
  <td>`is_move_constructible_v<F> && is_invocable_v<F, T>`</td>
  <td>`T` is a complete type.</td>
</tr>
<tr>
  <td>
```
template <typename F>
struct is_future_exception_continuation;
```
  </td>
  <td>`is_move_constructible_v<F> && is_invocable_v<F, exception_arg_t, exception_ptr>`</td>
  <td>`T` is a complete type.</td>
</tr>
<tr>
  <td>
```
template <typename F, typename T>
struct is_future_continuation;
```
  </td>
  <td>`is_future_value_continuation_v<F, T> || is_future_exception_continuation_v<F>`</td>
  <td>`T` is a complete type.</td>
</tr>
</table>

</center>

`SemiFuture` Requirements
-------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

1. A <dfn>semi future</dfn> is an object that can be bound to an executor to produce a [=future=].

2. A `SemiFuture` type for type `T` shall meet the `MoveConstructible` requirements, the `MoveAssignable` requirements, and the requirements described in the Tables below.

<center>

**Descriptive Variable Definitions**

<table border=1>
<tr>
  <th>Variable</th>
  <th>Definition</th>
</tr>
<tr>
  <td>`T`</td>
  <td>
    Either:
    * Any (possibly cv-qualified) object type that is not an array, or
    * (possibly cv-qualified) `void`.
  </td>
</tr>
<tr>
  <td>`SF<T>`</td>
  <td>A `SemiFuture` type for value type `T`.</td>
</tr>
<tr>
  <td>`sf`</td>
  <td>An rvalue of type `SF<T>`.</td>
</tr>
<tr>
  <td>`E`</td>
  <td>
    An executor type, either:
     * A `ThenExecutor` such that `execution::can_query_v<E, promise_contract_t<T>> == true`, or
     * A `OneWayExecutor` otherwise.
  </td>
</tr>
<tr>
  <td>`e`</td>
  <td>A value of type `E`.</td>
</tr>
<tr>
  <td>`CF<T, E>`</td>
  <td>
    A `ContinuableFuture` type for value type `T` and executor type `E`, either:
    * `decltype(execution::query(e, promise_contract_t<T>()).second)` if `E` is a `ThenExecutor` and `execution::can_query_v<E, promise_contract_t<T>> == true`, or
    * `standard_continuable_future<T>` otherwise.
  </td>
</tr>
</table>

<b>`SemiFuture` Requirements</b>

<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Operational Semantics</th>
</tr>
<tr>
  <td>`future_value_t<SF<T>>`</td>
  <td>`T`</td>
  <td></td>
</tr>
<tr>
  <td>`future_exception_t<SF<T>>`</td>
  <td>Implicitly convertible to `exception_ptr`.</td>
  <td></td>
</tr>
<tr>
  <td>`sf.via(e)`</td>
  <td>*implementation-defined*</td>
  <td>
    **Returns:** A `ContinuableFuture` for value type `T` that is bound to the executor `e` and will be made ready with the content of `sf` when `sf` is made ready.

    <!-- The compile-time requirements are captured by the description of the type `E` in the descriptive variable table -->

    **Throws:** If `!execution::query(e, promise_contract_t<T>).second`, throws any exception thrown by `!execution::query(e, oneway_t)`.
  </td>
</tr>
</table>

</center>

`ContinuableFuture` Requirements
--------------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

1. A <dfn>continuable future</dfn> is a [=future=] that is bound to an executor and can have continuations attached to it.

2. A `ContinuableFuture` shall meet the `SemiFuture` requirements and the requirements described in the Tables below.

<center>

**Descriptive Variable Definitions**

<table border=1>
<tr>
  <th>Variable</th>
  <th>Definition</th>
</tr>
<tr>
  <td>`E`</td>
  <td>An executor type.</td>
</tr>
<tr>
  <td>`e`</td>
  <td>A value of type `E`.</td>
</tr>
<tr>
  <td>`T`</td>
  <td>
    Either:
    * Any (possibly cv-qualified) object type that is not an array, or
    * (possibly cv-qualified) `void`.
  </td>
</tr>
<tr>
  <td>`CF<T, E>`</td>
  <td>A `ContinuableFuture` type for value type `T` and executor type `E`.</td>
</tr>
<tr>
  <td>`cf`</td>
  <td>A value of type `CF<T, E>`.</td>
</tr>
<tr>
  <td>`rcf`</td>
  <td>An rvalue of type `CF<T, E>`.</td>
</tr>
<tr>
 <td>`val`</td>
 <td>The value contained within the successfully completed future `rcf`.</td>
</tr>
<tr>
 <td>`ex`</td>
 <td>The exception contained within the exceptionally completed future `rcf`.</td>
</tr>
<tr>
  <td>`G`</td>
  <td>Any type such that `is_future_continuation_v<G, T> == true`.</td>
</tr>
<tr>
  <td>`g`</td>
  <td>An object of type `G`.</td>
</tr>
<tr>
  <td>`R`
  <td>
    Either:
    * If `is_same_v<remove_cv_t<T>, void> == true` and `invoke(g)` is well formed, `decltype(g())`.
    * If `is_same_v<remove_cv_t<T>, void> != true` and `invoke(g, val)` is well formed, `decltype(g(val))`.
    * Otherwise, `T`.
  </td>
</tr>
<tr>
  <td>`SF<T>`</td>
  <td>A `SemiFuture` type for value type `T`.</td>
</tr>
<tr>
  <td>`NORMAL`</td>
  <td>
    Either:
    * If `is_same_v<remove_cv_t<T>, void> == true`, `DECAY_COPY(std::forward<G>(g))()`, and
    * Otherwise, `DECAY_COPY(std::forward<G>(g))(std::move(val))`.
  </td>
</tr>
<tr>
  <td>`EXCEPTIONAL`</td>
  <td>
    The expression `DECAY_COPY(std::forward<G>(g))(exception_arg, std::move(ex))`.
  </td>
</tr>
</table>

<b>`ContinuableFuture` Requirements</b>

<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Operational Semantics</th>
</tr>
<tr>
  <td>`cf.get_executor()`</td>
  <td>`E`</td>
  <td>
    **Returns:** The executor that the future is bound to.
  </td>
</tr>
<tr>
  <td>`rcf.then(g)`</td>
  <td>`CF<E, R>`</td>
  <td>
    **Returns:** A `ContinuableFuture` that is bound to the executor `e` and
    that wraps the type returned by execution of either the value or exception
    operations implemented in the continuation.

    **Effects:**
      When `rcf` becomes nonexceptionally ready, and if `NORMAL` is a
      well-formed expression, creates an execution agent which invokes `NORMAL`
      at most once, with the call to `DECAY_COPY` being evaluated in the thread
      that called `.then`.

      Otherwise, when `rcf` becomes exceptionally ready, if `EXCEPTIONAL` is a
      well-formed expression, creates an execution agent which invokes
      `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
      in the thread that called `.then`.

      If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
      `decltype(EXCEPTIONAL)` shall be convertible to `R`.

      If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
      well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
      `decltype(val)`.

      If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
      invocation of `.then` shall be ill-formed.

      May block pending completion of `NORMAL` or `EXCEPTIONAL`.

      The invocation of `.then` synchronizes with
      (C++Std [intro.multithread]) the invocation of `g`.

      [=Fulfills=] the `ContinuableFuture` with the result of the `NORMAL` or
      `EXCEPTIONAL` expression, or any exception thrown by either.
      Otherwise, [=fulfills=] the `ContinuableFuture` with either `val` or `e`.

    <!-- This may be covered by the synchronization requirements in the front-matter text (e.g. "future/promise model") -->

    **Synchronization:** The destruction of the continuation that generates
      `rcf`'s value synchronizes with the invocation of `g` and with the destruction
      of `g`.
  </td>
</tr>
</table>

</center>


`SharedFuture` Requirements
--------------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

1. A <dfn>shared future</dfn> is a [=future=] that is copyable, is bound to an executor and that allows one or more continuation to be attached to it.

2. A `SharedFuture` shall meet the `ContinuableFuture` requirements, the `CopyConstructible` requirements, the `CopyAssignable` requirements and the requirements described in the Tables below.

<center>

Descriptive Variable Definitions

<table border=1>
<tr>
  <th>Variable</th>
  <th>Definition</th>
</tr>
<tr>
  <td>`E`</td>
  <td>An executor type.</td>
</tr>
<tr>
  <td>`e`</td>
  <td>A value of type `E`.</td>
</tr>
<tr>
  <td>`T`</td>
  <td>Any (possibly cv-qualified) object type that is not an array.</td>
</tr>
<tr>
  <td>`CF<T, E>`</td>
  <td>A `ContinuableFuture` type for executor type `E` and value type `T`.</td>
</tr>
<tr>
  <td>`SHF<E, T>`</td>
  <td>A `SharedFuture` type for executor type `E` and value type `T`.</td>
</tr>
<tr>
  <td>`shf`</td>
  <td>A value of type `SHF<E, T>`.</td>
</tr>
<tr>
  <td>`NORMAL`</td>
  <td>
    The expression `DECAY_COPY(std::forward<G>(g))(val)` if
    `T` is non-void and `DECAY_COPY(std::forward<G>(g))()` if `T` is void.
  </td>
</tr>
<tr>
  <td>`EXCEPTIONAL`</td>
  <td>
    The expression
    `DECAY_COPY(std::forward<G>(g))(exception_arg, ex)`,
  </td>
</tr>
</table>

`SharedFuture` Requirements

<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Operational Semantics</th>
</tr>
<tr>
  <td>`shf.then(g)`</td>
  <td>
    **If** `T` is non-void and `INVOKE(declval<G>(), declval<T>())` or if `T` is
      `void` and `INVOKE(declval<G>())` is valid:

      `CF<E, decltype(INVOKE(declval<G>(), declval<T>()))>`

    **Otherwise**:

      `CF<T, E>`
  </td>
  <td>
    **Returns:** A `ContinuableFuture` that is bound to the executor `e` and
    that wraps the type returned by execution of either the value or exception
    operations implemented in the continuation.

    **Effects:**
      When `shf` becomes nonexceptionally ready, and if `NORMAL` is a
      well-formed expression, creates an execution agent which invokes `NORMAL`
      at most once, with the call to `DECAY_COPY` being evaluated in the thread
      that called `.then`.

      Otherwise, when `shf` becomes exceptionally ready, if `EXCEPTIONAL` is a
      well-formed expression, creates an execution agent which invokes
      `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
      in the thread that called `.then`.

      If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
      `decltype(EXCEPTIONAL)` shall be convertible to `R`.

      If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
      well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
      `decltype(val)`.

      If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
      invocation of `.then` shall be ill-formed.

      May block pending completion of `NORMAL` or `EXCEPTIONAL`.

      The invocation of `.then` synchronizes with
      (C++Std [intro.multithread]) the invocation of `g`.

      [=Fulfills=] the `ContinuableFuture` with the result of the `NORMAL` or
      `EXCEPTIONAL` expression, or any exception thrown by either.
      Otherwise, [=fulfills=] the `ContinuableFuture` with either `val` or `e`.

    **Postconditions:** Has no observable affect on `sfh`.
  </td>
</tr>
<tr>
  <td>`shf.via(e)`</td>
  <td>Implementation-defined</td>
  <td>
    **Returns:** A `ContinuableFuture` for type `T` that is bound to the executor `e`.

    **Effect:** Returns an implementation-defined `ContinuableFuture` onto which continuations can be attached that will run on `e`.

    **Success:** Succeeds if:
     * `e` is a `ThenExecutor` where `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)` is valid.
     * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

     Fails at compile-time otherwise.


    **Postconditions:** Has no observable affect on `sfh`.
  </td>
</tr>
</table>

</center>

`std::standard_promise`
-----------------------

```
template<class T>
class standard_promise {
public:
    using promise_default_executor = implementation-defined;

    standard_promise() = default;
    standard_promise(standard_promise&&) = default;
    standard_promise(const standard_promise&) = delete;

    standard_continuable_future<T, promise_default_executor>
      get_continuable_future();

    standard_semi_future<T> get_semi_future();

    template<class Value>
    void set_value(Value&& val);

    template<class Error = std::exception_ptr>
    void set_exception(Error&& val);
};
```

The default executor type for promises allows for efficient promise->future
code. This executor is intended for use only locally. It may be optimised
using thread-local storage and should not be constructible. It is not copyable
and its lifetime is not guaranteed to outlive a single continuation chain
starting with a promise.

<br/>
```
standard_promise();
```

 * *Effects:* Default constructs a `standard_promise` object that refers to a
       [=promise=] and from which can be obtained a valid [=future=].

 * *Postconditions:*
     * valid() == true.

<br/>
```
standard_promise(standard_promise&& rhs);
```

 * *Effects:*  Move constructs a `standard_promise` object from `rhs` that refers
       to the same [=promise=] and its associated with the same [=future=]
       (if `rhs` refers to a [=promise=]).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
     * rhs.valid() == false.

<br/>
```
standard_continuable_future<T, promise_default_executor> get_continuable_future();
```

* *Effects:* Obtained a `standard_continuable_future` that completes on the
    promise's default executor when `this->set_value(v)` or
    `this->set_exception(e)` is called.

* *Postconditions:* Further calls to `get_continuable_future()` or
    to `get_semi_future()` will throw.

<br/>
```
standard_semi_future<T> get_semi_future();
```

* *Effects:* Obtained a `standard_semi_future` that completes when
    `this->set_value(v)` or `this->set_exception(e)` is called.

* *Postconditions:* Further calls to `get_continuable_future()` or
    to `get_semi_future()` will throw.

<br/>
```
template<class Value>
void set_value(Value&& val);
```
 * *Requires:* The result of `std::decay_t<Value>` is `T`.

 * *Effects:* Completes the associated future with value `val`.

 * *Postconditions:* Further calls to `set_value` or `set_exception` may throw.

<br/>
```
template<class Error = std::exception_ptr>
void set_exception(Error&& ex);
```

 * *Requires:* The result of `std::decay_t<Error>` is `std::exception_ptr`.

 * *Effects:* Completes the associated future with exception `ex`.

 * *Postconditions:* Further calls to `set_value` or `set_exception` may throw.



`std::standard_semi_future`
---------------------------

```
template<class T>
class standard_semi_future {
public:
    using value_type = T;

    standard_semi_future(standard_semi_future&&) = default;
    standard_semi_future(const standard_semi_future&) = delete;

    standard_semi_future& operator=(const standard_semi_future&) = delete;
    standard_semi_future& operator=(standard_semi_future&&) = default;

    template<class E>
    explicit standard_semi_future(standard_continuable_future<T, E>&&);

    template<class E>
    explicit standard_semi_future(standard_shared_future<T, E>&&);

    template<class EI>
    standard_continuable_future<T, EI> via(EI) &&;
};
```

<br/>
```
standard_continuable_future(standard_semi_future&& rhs);
```

 * *Effects:*  Move constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).


 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
     * rhs.valid() == false.

<br/>
```
standard_semi_future(const standard_semi_future& rhs);
```

 * *Effects:* Copy constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the
    constructor invocation. The validity of rhs does not change.

<br/>
```
template<class E>
standard_semi_future(standard_continuable_future<T, E>&& rhs);
```

* *Effects:* Move constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

* *Postconditions:*
   * valid() returns the same value as rhs.valid() prior to the constructor invocation.
   * rhs.valid() == false.


<br/>
```
template<class E>
explicit standard_semi_future(standard_shared_future<T, E>&& rhs);

template<class E>
explicit standard_semi_future(const standard_shared_future<T, E>& rhs);
```

 * *Effects:* Move constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

 * *Postconditions:*
    * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
    * rhs.valid() == false.

<br/>
```
standard_continuable_future<T, EI> via(EI ex) &&;
```

 * *Effects:* Returns a new future that will complete when this completes but
    on which continuations will be enqueued to a new executor.

 * *Returns:* A standard_continuable_future modified to carry executor ex of
    type EI.

 * *Requires:*
   * `e` is a `ThenExecutor` where
     `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or
     `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)`
     is valid.
   * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

 * *Postconditions:* valid() == false.

<br/>
```
bool valid() const noexcept;
```

 * *Returns:* Returns true if this is a valid future. False otherwise.

`std::standard_continuable_future`
----------------------------------

```
template<class T, class E>
class standard_continuable_future {
public:
    using value_type = T;
    using executor_type = Ex;
    using semi_future_type = standard_semi_future<T>;

    standard_continuable_future(const standard_continuable_future&) = delete;
    standard_continuable_future(standard_continuable_future&&) = default;

    standard_continuable_future& operator=(const standard_continuable_future&) = delete;
    standard_continuable_future& operator=(standard_continuable_future&&) = default;

    template<class E>
    explicit standard_continuable_future(standard_shared_future<T, E>&&);
    template<class E>
    explicit standard_continuable_future(const standard_shared_future<T, E>&);

    template<class ReturnFuture, class F>
    ReturnFuture then(FutureContinuation&&) &&;

    template<class EI>
    standard_continuable_future<T, EI> via(EI) &&;

    E get_executor() const;
    standard_semi_future<T> semi() &&;
    standard_shared_future<T, E> share() &&;

    bool valid() const
}
};
```

<br/>
```
standard_continuable_future(standard_continuable_future&& rhs);
```

 * *Effects:* Move constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
     * rhs.valid() == false.

<br/>
```
standard_continuable_future(const standard_continuable_future& rhs);
```

 * *Effects:* Copy constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the
    constructor invocation. The validity of rhs does not change.

<br/>
```
template<class E>
explicit standard_continuable_future(standard_shared_future<T, E>&& rhs);
```

 * *Effects:* Move constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
     * rhs.valid() == false.

<br/>
```
template<class E>
explicit standard_continuable_future(const standard_shared_future<T, E>& rhs);
```

 * *Effects:* Copy constructs a future object from `rhs` that refers to the
    same [=future=] and its associated with the same [=promise=] (if `rhs`
    refers to a [=future=]).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the
    constructor invocation. The validity of rhs does not change.

<br/>
```
template<class ReturnFuture, class F>
ReturnFuture then(F&&) &&;
```

 * *Requires:*
    F satisfies the requirements of FutureContinuation.

 * *Returns:* A `ContinuableFuture` that is bound to the executor `e` and
    that wraps the type returned by execution of either the value or exception
    operations implemented in the continuation. The type of the returned
    `ContinuableFuture` is defined by `Executor` `E`.

 * *Effects:*
     * For `NORMAL` defined as the expression `DECAY_COPY(std::forward<F>(g))(val)` if
        `T` is non-void and `DECAY_COPY(std::forward<F>(g))()` if `T` is void.

     * For `EXCEPTIONAL` defined as the expression
        `DECAY_COPY(std::forward<F>(f))(exception_arg, ex)`,

     * When `*this` becomes nonexceptionally ready, and if `NORMAL` is a
        well-formed expression, creates an execution agent which invokes `NORMAL`
        at most once, with the call to `DECAY_COPY` being evaluated in the thread
        that called `.then`.

     * Otherwise, when `*this` becomes exceptionally ready, if `EXCEPTIONAL` is a
        well-formed expression, creates an execution agent which invokes
        `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
        in the thread that called `.then`.

     * If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
        `decltype(EXCEPTIONAL)` shall be convertible to `R`.

     * If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
        well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
        `decltype(val)`.

     * If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
        invocation of `.then` shall be ill-formed.

     * May block pending completion of `NORMAL` or `EXCEPTIONAL`.

     * The invocation of `.then` synchronizes with
        (C++Std [intro.multithread]) the invocation of `f`.

     * Stores the result of either the `NORMAL` or `EXCEPTIONAL` expression, or
        any exception thrown by either, in the associated shared state of the
        resulting `ContinuableFuture`. Otherwise, stores either `val` or `e` in
        the associated shared state of the resulting `ContinuableFuture`.

 * *Postconditions:* valid() == false.

<br/>
```
standard_continuable_future<T, EI> via(EI ex) &&;
```

 * *Effects:* Returns a new future that will complete when this completes but
    on which continuations will be enqueued to a new executor.

 * *Returns:* A standard_continuable_future modified to carry executor ex of
    type EI.

 * *Requires:*
   * `e` is a `ThenExecutor` where
      `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or
      `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)`
      is valid.
   * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

  * *Postconditions:* valid() == false.

<br/>
```
E get_executor() const;
```
 * *Returns:* If is_valid() returns true returns the executor contained within the
    future. Otherwise throws std::future_error.

<br/>
```
standard_semi_future<T> semi() &&;
```
 * *Returns:*
    Returns a standard_semi_future of the same value type as \*this and that
    completes when this completes, but that erases the executor. is_valid() on the
    returned standard_semi_future will return the same value as is_valid() on
    \*this.

<br/>
```
bool valid() const noexcept;
```

 * *Returns:* Returns true if this is a valid future. False otherwise.

<br/>
```
standard_shared_future<T, E> share() &&;
```

 * *Returns:* standard_shared_future<R>(std::move(\*this)).

 * *Postconditions:* valid() == false.





`std::standard_shared_future`
----------------------------------

```
namespace std {
  template<class T, class E>
  class standard_shared_future {
  public:
      using value_type = T;
      using executor_type = Ex;
      using semi_future_type = standard_semi_future<T>;

      standard_shared_future(const standard_shared_future&) = default;
      standard_shared_future(standard_shared_future&&) = default;

      standard_shared_future& operator=(const standard_shared_future&) = default
      standard_shared_future& operator=(standard_shared_future&&) = default;

      template<class E>
      explicit standard_shared_future(standard_continuable_future<T, E>&&);

      template<class ReturnFuture, class F>
      ReturnFuture then(FutureContinuation&&);

      template<class EI>
      standard_shared_future<T, EI> via(EI);

      E get_executor() const;
      standard_semi_future<T> semi();

      bool valid() const;
  }
  };
}
```

<br/>
```
standard_shared_future(standard_shared_future&& rhs);
```

 * *Effects:*  Move constructs a future object that refers to the shared state that
      was originally referred to by rhs (if any).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor invocation.
     * rhs.valid() == false.

<br/>
```
standard_shared_future(const standard_shared_future& rhs);
```

 * *Effects:* Copy constructs a future object that refers to the shared state that was originally referred to by rhs (if any).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the constructor invocation. The validity of rhs does not change.

<br/>
```
explicit standard_shared_future(standard_continuable_future&& rhs);
```

 * *Effects:* Move constructs a future object that refers to the shared state that
      was originally referred to by rhs (if any).

 * *Postconditions:*
    * valid() returns the same value as rhs.valid() prior to the constructor invocation.
    * rhs.valid() == false.

<br/>
```
template<class ReturnFuture, class F>
ReturnFuture then(F&&);
```

 * *Requires:* F satisfies the requirements of FutureContinuation.

 * *Returns:* A `ContinuableFuture` that is bound to the executor `e` and
      that wraps the type returned by execution of either the value or exception
      operations implemented in the continuation. The type of the returned
      `ContinuableFuture` is defined by `Executor` `E`.

 * *Effects:*
     * For `NORMAL` defined as the expression `DECAY_COPY(std::forward<F>(g))(val)` if
        `T` is non-void and `DECAY_COPY(std::forward<F>(g))()` if `T` is void.

     * For `EXCEPTIONAL` defined as the expression
        `DECAY_COPY(std::forward<F>(f))(exception_arg, ex)`,

     * When `*this` becomes nonexceptionally ready, and if `NORMAL` is a
        well-formed expression, creates an execution agent which invokes `NORMAL`
        at most once, with the call to `DECAY_COPY` being evaluated in the thread
        that called `.then`.

     * Otherwise, when `*this` becomes exceptionally ready, if `EXCEPTIONAL` is a
        well-formed expression, creates an execution agent which invokes
        `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
        in the thread that called `.then`.

     * If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
        `decltype(EXCEPTIONAL)` shall be convertible to `R`.

     * If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
        well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
        `decltype(val)`.

     * If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
        invocation of `.then` shall be ill-formed.

     * May block pending completion of `NORMAL` or `EXCEPTIONAL`.

     * The invocation of `.then` synchronizes with
        (C++Std [intro.multithread]) the invocation of `f`.

     * Stores the result of either the `NORMAL` or `EXCEPTIONAL` expression, or
        any exception thrown by either, in the associated shared state of the
        resulting `ContinuableFuture`. Otherwise, stores either `val` or `e` in
        the associated shared state of the resulting `ContinuableFuture`.

 * *Postconditions:* No observable change to \*this.


<br/>
```
standard_shared_future<T, EI> via(EI ex);
```

 * *Effects:* Returns a new future that will complete when this completes but
      on which continuations will be enqueued to a new executor.

 * *Returns:* A standard_shared_future modified to carry executor ex of type EI.

 * *Requires:*
   * `e` is a `ThenExecutor` where `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)` is valid.
   * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

 * *Postconditions:* No observable change to \*this.

 <br/>
```
E get_executor() const;
```
 * *Returns:* If is_valid() returns true returns the executor contained within the
    future. Otherwise throws std::future_error.

<br/>
```
standard_semi_future<T> semi();
```
 * *Returns:*
      Returns a standard_semi_future of the same value type as \*this and that
      completes when this completes, but that erases the executor. is_valid() on the
      returned standard_semi_future will return the same value as is_valid() on
      \*this.

<br/>
```
bool valid() const noexcept;
```
 * *Returns:* Returns true if this is a valid future. False otherwise.


`std::this_thread::future_wait`
----------------------------------
In [thread.syn] and [thread.thread.this] extend `this_thread` namespace:
```
namespace std {
  namespace this_thread {
    template<class Future>
      void future_wait(Future& f) noexcept;
  }
}
```

<br/>
To [thread.thread.this] add:
```
template<class Future>
  void future_wait(Future& f) noexcept;
```

 * *Requires:* SemiFuture<Future>

 * *Effects:* Blocks the calling thread until `f` becomes ready.

 * *Synchronization:* The destruction of the continuation that generates `f`'s
      value synchronizes-with the corresponding `future_wait` return.


`std::this_thread::future_get`
----------------------------------
In [thread.syn] and [thread.thread.this] extend `this_thread` namespace:
```
namespace std {
  namespace this_thread {
    template<class Future>
      auto future_get(Future&& f) -> std::decay_t<Future>::value_type;
  }
}
```

<br/>
To [thread.thread.this] add:
```
template<class Future>
  auto future_get(Future&& f)
    -> std::decay_t<Future>::value_type;
```
 * *Requires:* SemiFuture<Future>

 * *Effects:* Blocks the calling thread until `f` becomes ready.

 * *Returns:*
     * If `f` becomes ready with a value, moves the value from `f` and returns it
        to the caller.

 * *Synchronization:* The destruction of the continuation that generates `f`'s
      value synchronizes-with the corresponding `future_get` return.

 * *Throws:* If `f` becomes ready with an exception, that exception is rethrown.

<br/>
`FutureContinuation` helper functions
-------------------------------------

### Function template `on_value`

<!-- Following parallel algorithms precedent, these functions should take their template parameters by value -->

```c++
template <class F>
/* see below */ on_value(F f);
```

**Requires:**
  - For a (possibly cv-qualified) object type `T`, `INVOKE(declval<F>(), declval<T>())` must be valid
  - `F` must meet the requirements of `MoveConstructible`

**Returns:**
A `FutureContinuation` object, `fc`, of implementation-defined type that meets the
following operational semantics:

- `fc(t)` is valid for objects `t` of type `T` and has the same effects
    as `INVOKE(ff, t)`, where `ff` is an instance of `F` move-constructed from the
    argument to `on_value()`.
    The object `ff` is constructed before the return of `on_value()` and destroyed when `fc` is destroyed.
- `fc` cannot be invoked with `exception_arg` as the first argument when calling `fc` with more than one argument.
    [*Note:* This means that calling `fc` in this way must fail to compile *‚Äî end note*]


### Function template `on_error`

<!-- Following parallel algorithms precedent, these functions should take their template parameters by value -->

```c++
template <class F>
/* see below */ on_error(F f);
```

**Requires:**
  - `INVOKE(declval<F>(), declval<exception_ptr>())` must be valid
  - `F` must meet the requirements of `MoveConstructible`

**Returns:**
A `FutureContinuation` object, `fc`, of implementation-defined type that meets the
following operational semantics:

- `fc(exception_tag, e)` is valid for objects `e` of type `exception_ptr` and has the same effects
    as `INVOKE(ff, e)`, where `ff` is an instance of `F` move-constructed from the
    argument to `on_error()`.
    The object `ff` is constructed before the return of `on_error()` and destroyed when `fc` is destroyed.
- `fc` cannot be invoked with one argument. [*Note:* This means that calling
    `fc` with one argument must fail to compile *‚Äî end note*]


```c++
template <class F>
/* see below */ on_expected(F f);
```

**Requires:**
  - For a (possibly cv-qualified) object type `T` and a (possibly cv-qualified) object of type `E`, the expressions `INVOKE(declval<F>(), declval<T>())` and `INVOKE(declval<F>(), declval<exception_ptr>())` must be valid.
  - `F` must meet the requirements of `MoveConstructible`

**Returns:**
A `FutureContinuation` object, `fc`, of implementation-defined type that meets the
following operational semantics:

- `fc(t)` is valid for objects `t` of type `T` and has the same effects
    as `INVOKE(ff, t)`, where `ff` is an instance of `F` move-constructed from the
    argument to `on_expected()`.
    The object `ff` is constructed before the return of `on_expected()` and destroyed when `fc` is destroyed.
- `fc(exception_tag, e)` is valid for objects `e` of type `exception_ptr` and has the same effects
    as `INVOKE(ff, e)`, where `ff` is an instance of `F` move-constructed from the
    argument to `on_expected()`.
    The object `ff` is constructed before the return of `on_expected()` and destroyed when `fc` is destroyed.


<!-- Note: I've omitted on_visitor() because it is identical in terms of operational semantics to on_expected() and/or requires the pair of types T, E to be explicitly defined -->

```c++
template <class F, class G>
/* see below */ on_value_or_error(F f, G g);
```

**Requires:**
  - For a (possibly cv-qualified) object type `T`,
    `INVOKE(declval<F>(), declval<T>())` and
    `INVOKE(declval<G>(), declval<exception_ptr>())` must be valid.
  - `F` and `G` must meet the requirements of `MoveConstructible`

**Returns:**
A `FutureContinuation` object, `fc`, of implementation-defined type that meets the
following operational semantics:

- `fc(t)` is valid for objects `t` of type `T` and has the same effects
    as `INVOKE(ff, t)`, where `ff` is an instance of `F` move-constructed from the
    argument to `on_value_or_error()`.
    The object `ff` is constructed before the return of `on_value_or_error()` and destroyed when `fc` is destroyed.
- `fc(exception_tag, e)` is valid for objects `e` of type `exception_ptr` and has the same effects
    as `INVOKE(gg, e)`, where `gg` is an instance of `G` move-constructed from the
    argument to `on_value_or_error()`.
    The object `gg` is constructed before the return of `on_value_or_error()` and destroyed when `fc` is destroyed.



Proposed Addition to Executors P0443
=============================

[p0443](https://wg21.link/P0443) defines a collection of executor types intended
for use managing the execution of tasks on resources.
There are three fundamental executor categories that cover directionality and
control of launch:
 * one-way
 * two-way
 * then

The first two could be considered *immediately launched*. That is that once
handed to the executor, they may start immediately, assuming the internal
executor policies and resources allow it. This makes them very useful for
lazy-launch scenarios.

Lazy launch scenarios are common in callback-based code, and in a wide range of
future library implementations such as
[folly](https://github.com/facebook/folly/tree/master/folly/futures).
In these designs, a callback is executed on completion of some asynchronous
work, and that callback enqueues work into the executor.
This means that work is enqueued only after all dependencies are satisfied.

Then-executors, on the other hand, are intended for explicitly deferred work.
Work can be handed to the executor dependent on prior work, before that prior
work is completed.
This design is fundamentally different, but offers scope for optimization by
the executor of chains of dependencies that it can batch, without running
additional code on completion of each.

The current executor design is intentionally generic - it makes few requirements
on the future types it can use as input dependencies for the `then_execute` and
`bulk_then_execute` operations.
We can assume that for a future returned by a previous call to `then_execute`
or `bulk_then_execute`, the executor understands the implementation of the
future can can perform whatever dependence tracking and optimization necessary.
This then is an implementation detail.

However, there will also be interactions where a task to run on one executor is dependent on one produced by another. For this to be practical, we need a standardised mechanism to tie the two executors together.
This amounts to a standard API for triggering deferred work.

Proposed solution
-------------------

To solve this we provide two things:
 * A promise concept, that allows setting of value and/or exception.
 * A mechanism to retrieve from an executor a pair of a promise and a future, such that the future is a valid input dependence for a call to `then_execute` or `bulk_then_execute`.

The promise is a write-only concept. This simplifies the definition and improves flexibility.

The future is not a full future in the sense of future concepts. It is merely a token that completes when the promise is satisfied. This means that it is useful only for connecting to `then_execute` or `bulk_then_execute` on the executor that provided the result.

Proposed New Wording
====================

Wording supplements current text in [p0443](https://wg21.link/P0443).

1.1.x `Promise` requirements
--------------------

A type `P` meets the `Promise` requirements for some value type `T` if an
instance `p` of `P` satisfies the requirements in the table below. `T` may be
void.

<table>
  <tr>
    <th>Expression</th>
    <th>Return Type</th>
    <th>Operational semantics</th>
  </tr>
  <tr>
    <td>`p.set_value(T)`</td>
    <td>void</td>
    <td>Completes the promise with a value.</td>
  </tr>
  <tr>
    <td>`p.set_exception(std::exception_ptr)`</td>
    <td>void</td>
    <td>Completes the promise with an exception wrapped in a `std::exception_ptr`.</td>
  </tr>
</table>


1.3.3.2 Promise contract
--------------------

```
template <T>
struct promise_contract_t
{
  static constexpr bool is_requirable = false;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type
    = std::pair<std::standard_promise<T>, std::standard_semi_future<T>>;

  template<class Executor>
  static constexpr decltype(auto) static_query_v
    = Executor::query(promise_contract_t());

  template<class Executor>
    friend polymorphic_query_result_type
      query(const Executor& ex, const promise_contract_t&);
};
```

The `promise_contract_t` property can be used only with query.

The result of a query of the `promise_contract_t` property applied to a
`ThenExecutor` or `BulkThenExecutor` is a `std::pair` consisting of a `Promise`
and an implementation-defined token type that will be interpreted as a valid
input future by calls to `then_execute` or `bulk_then_execute` and that is
satisfied by calling `set_value` or `set_exception` on the promise.

The value returned from `execution::query(e, promise_contract_t<T>)`, where `e`
is an executor and `T` is a type, should be unique for any given call.
When `e` is a `ThenExecutor` or `BulkThenExecutor` the result of the query is a
`std::pair` where first value is an instance of a type matching the `Promise`
requirements and the second is a token type that `e` will interpret as a valid
future parameter to calls to `then_execute` or `bulk_then_execute`.

```
template<class Executor>
  friend std::pair<std::standard_promise<T>, std::standard_semi_future<T>>
    query(const Executor& ex, const promise_contract_t&);
```
 * *Returns:* A `std::pair` where the first value is a
     `std::standard_promise<T>` and the second is a
     `std::standard_semi_future<T>` such that the future was
     retrieved from the promise.

 * *Remarks:* This function shall not participate in overload resolution unless
     `executor_future_t<Executor, T>` is `std::standard_semi_future<T>`.


1.3.3.2 Cancellable promise contract
--------------------

```
template <T, C>
struct cancellable_promise_contract_t
{
  static constexpr bool is_requirable = false;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type
    = std::pair<std::standard_promise<T>, std::standard_semi_future<T>>;

  template<class Executor>
  static constexpr decltype(auto) static_query_v
    = Executor::query(promise_contract_t());

  template<class Executor>
    friend std::pair<std::standard_promise<T>, std::standard_semi_future<T>>
      query(const Executor& ex, const cancellable_promise_contract_t&);

  CancellationCallback cancellation_callback;
};
```

The `cancellable_promise_contract_t` property can be used only with query.
`cancellable_promise_contract_t` differs from `promise_contract_t` in that the
query carries a cancellation callback, `cancellation_callback`, that will be
called as `std::invoke(cancellation_callback)` by the `ThenExecutor` on
cancellation of the task dependent on the future resulting from the
`cancellable_promise_contract_t` query.

The result of a query of the `cancellable_promise_contract_t` property applied
to a `ThenExecutor` or `BulkThenExecutor` is a `std::pair` consisting of a
`Promise` and an implementation-defined token type that will be interpreted as
a valid input future by calls to `then_execute` or `bulk_then_execute`, that
is satisfied by calling `set_value` or `set_exception` on the promise and that
supports cancellation by the executor.

The value returned from
`execution::query(e, cancellable_promise_contract_t<T>{cancellation_callback})`,
where `e` is an executor and `T` is a type, should be unique for any given call.
When `e` is a `ThenExecutor` or `BulkThenExecutor` the result of the query is a
`std::pair` where first value is an instance of a type matching the `Promise`
requirements and the second is a token type that `e` will interpret as a valid
future parameter to calls to `then_execute` or `bulk_then_execute`.

```
template<class Executor>
  friend std::pair<std::standard_promise<T>, std::standard_semi_future<T>>
    query(const Executor& ex, const cancellable_promise_contract_t&);
```
 * *Returns:* A `std::pair` where the first value is a `std::promise<T>` and the
      second is a `std::standard_semi_future<T>` such that the future was retrieved
      from the promise.

 * *Remarks:* This function shall not participate in overload resolution unless
      `executor_future_t<Executor, T>` is `std::standard_semi_future<T>`.


Proposed Modifications to Executors P0443
=============================
[p0443](https://wg21.link/P0443) currently requires `std::experimental::future`
due to the absence of a complete future type in the core standard.

This paper provides the wider set of tasks and as a result, the current text in
[p0443](https://wg21.link/P0443) should be modified as follows.


Future requirements
--------------------
Drop this entire section and replace with the requirements from this paper.


TwoWayExecutor requirements
--------------------
In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.


In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.



ThenExecutor requirements
--------------------
In the type requirements list.

**Replace:**
 * fut denotes a future object satisfying the Future requirements,

**With:**
 * fut denotes a future object that:
     * was returned by a call to `x.twoway_execute`, `x.bulk_twoway_execute`,
        `x.then_execute`, or `x.bulk_then_execute` and meets the
        `ContinuableFuture` requirements.
     * was returned by a call to `execution::query(x, promise_contract_t<T>)` or
        `execution::query(x, cancellable_promise_contract_t<T>)`

In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.


In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.


BulkTwoWayExecutor requirements
--------------------
In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFutureFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.

In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.


BulkThenExecutor requirements
--------------------
In the type requirements list.

**Replace:**
 * fut denotes a future object satisfying the Future requirements,

**With:**
 * fut denotes a future object that:
     * was returned by a call to `x.twoway_execute`, `x.bulk_twoway_execute`,
        `x.then_execute`, or `x.bulk_then_execute` and meets the
        `ContinuableFuture` requirements.
     * was returned by a call to `execution::query(x, promise_contract_t<T>)` or
        `execution::query(x, cancellable_promise_contract_t<T>)`.

In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFutureFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.


In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.


twoway_t customization points
--------------------
**Replace:**

    it is `std::experimental::future<T>`

**with:**

    it is `std::standard_continuable_future<T, E1>` such that a call to
   `get_executor()` returns a copy of `e1`


single_t customization points
--------------------
**Replace:**

    it is `std::experimental::future<T>`

**with:**

    it is `std::standard_continuable_future<T, E1>` such that a call to
    `get_executor()` returns a copy of `e1`


Properties to indicate if blocking and directionality may be adapted
--------------------
Remove `twoway_t` from the **Requirements** column of hte table.

Remove note referring to `std::experimental::future`.

[*Note:* `std::experimental::future` is not used and the replacemnt does not
 have a blocking wait so this is no longer relevant.]


Class template executor
--------------------
**Replace:**
```
  template<class Function>
    std::experimental::future<result_of_t<decay_t<Function>()>>
      twoway_execute(Function&& f) const
```

**With:**
```
  template<class Function>
    std::standard_semi_future<result_of_t<decay_t<Function>()>>
      twoway_execute(Function&& f) const
```

**Replace:**
```
  template<class Function, class ResultFactory, class SharedFactory>
    std::experimental::future<result_of_t<decay_t<ResultFactory>()>>
      bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```

**With:**
```
  template<class Function, class ResultFactory, class SharedFactory>
    std::standard_semi_future<result_of_t<decay_t<ResultFactory>()>>
      bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```

[*Note:* We lose the executor information here. Potentially we should encode
 the future type, including its executor, in the properties of the polymorphic
 wrapper.]


executor operations
--------------------
**Replace:**

```
template<class Function>
  std::experimental::future<result_of_t<decay_t<Function>()>>
    twoway_execute(Function&& f) const
```

**With:**

```
template<class Function>
  /* implementation-defined future type */
    twoway_execute(Function&& f) con
```

**Replace:**

Returns: A future, whose shared state is made ready when the future returned by
e.twoway_execute(f2) is made ready, containing the result of f1() or any
exception thrown by f1(). [Note: e2.twoway_execute(f2) may return any future
type that satisfies the Future requirements, and not necessarily
std::experimental::future. One possible implementation approach is for the
polymorphic wrapper to attach a continuation to the inner future via that
object's then() member function. When invoked, this continuation stores the
result in the outer future's associated shared and makes that shared state
ready. --end note]

**With:**

*Returns:* A value whose type satisfies the `ContinuableFuture` requirements.
The returned future is made ready when `f1()` completes execution, with the
result of `f1()` if `decltype(f1())` is non-void, void completion if
`decltype(f1())` is void or any exception thrown by `f1()`.


**Replace:**

template<class Function, class ResultFactory, class SharedFactory>
  std::experimental::future<result_of_t<decay_t<ResultFactory>()>>
    void bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;


**With:**
```
template<class Function, class ResultFactory, class SharedFactory>
  /* implementation-defined future type */
     bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```


**Replace:**

*Returns:* A future, whose shared state is made ready when the future returned
by e.bulk_twoway_execute(f2, n, rf2, sf2) is made ready, containing the result
in r1 (if decltype(rf1()) is non-void) or any exception thrown by an
invocationf1. [Note: e.bulk_twoway_execute(f2) may greturn any future type that
satisfies the Future requirements, and not necessarily std::experimental::future.
One possible implementation approach is for the polymorphic wrapper to attach a
continuation to the inner future via that object's then() member function. When
invoked, this continuation stores the result in the outer future's associated
shared and makes that shared state ready. --end note]

**With:**

*Returns:* A value whose type satisfies the `ContinuableFuture` requirements.
The returned future is made ready when `f1()` completes execution, with
the result in `r1` (if `decltype(rf1())` is non-void), valueless completion
(if `decltype(rf1())` is void) or any exception thrown by an invocation `f1`.


static_thread_pool executor types
--------------------
**Replace:**
```
    template<class Function>
      std::experimental::future<result_of_t<decay_t<Function>()>>
        twoway_execute(Function&& f) const

    template<class Function, class Future>
      std::experimental::future<result_of_t<decay_t<Function>(decay_t<Future>)>>
        then_execute(Function&& f, Future&& pred) const;

    template<class Function, class SharedFactory>
      void bulk_execute(Function&& f, size_t n, SharedFactory&& sf) const;

    template<class Function, class ResultFactory, class SharedFactory>
      std::experimental::future<result_of_t<decay_t<ResultFactory>()>>
        void bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```

**With:**
```
  template<class Function>
    std::standard_continuable_future<result_of_t<decay_t<Function>()>, C>
      twoway_execute(Function&& f) const

  template<class Function, class Future>
    std::standard_continuable_future<result_of_t<decay_t<Function>(decay_t<Future>)>, C>
      then_execute(Function&& f, Future&& pred) const;

  template<class Function, class SharedFactory>
    void bulk_execute(Function&& f, size_t n, SharedFactory&& sf) const;

  template<class Function, class ResultFactory, class SharedFactory>
    std::standard_continuable_future<result_of_t<decay_t<ResultFactory>()>>, C>
      void bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const
```

Replace the same instances in the documentation section below the main code
block.
