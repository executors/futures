<pre class='metadata'>
Title: Futures
Shortname: PTODO
Revision: 0
Audience: SG1
Status: D
Group: WG21
URL: TODO
!Source: <a href="https://github.com/executors/futures/blob/master/futures.bs">github.com/executors/futures/blob/master/futures.bs</a>
Editor: Lee Howes, Facebook, lwh@fb.com
Editor: Bryce Adelstein-Lelbach, Nvidia, brycelelbach@gmail.com
Editor: David S. Hollman, Sandia National Labs, dshollm@sandia.gov
Abstract: Executor-compatible Futures for C++.
</pre>

Introduction {#intro}
=====================

Introduction here.


<code>SemiFuture</code> requirements {#semifuture}
=========================




<code>ContinuableFuture</code> requirements {#continuablefuture}
================================



Type: <code>std::standard_promise</code> {#type_standard_promise}
=============================

```c++
template<class T>
class standard_promise {
public:
    using promise_default_executor = implementation-defined;

    standard_future<T, promise_default_executor> get_future();
    standard_semi_future<T> get_semi_future();
};
```

The default executor type for promises allows for efficient promise->future
code. This executor is intended for use only locally. It may be optimised
using thread-local storage and should not be constructible. It is not copyable
and its lifetime is not guaranteed to outlive a single continuation chain
starting with a promise.

Type: <code>std::standard_semi_future</code> {#type_standard_semi_future}
=================================

```c++
template<class T>
class standard_semi_future {
public:
    using value_type = T;

    // StandardSemiFuture may be constructed already complete
    standard_semi_future(T);
    standard_semi_future(standard_semi_future&&) = default;
    standard_semi_future(const standard_semi_future&) = delete;

    // standard_semi_future may be constructed from any type
    // meeting the ContinuableFuture requirements
    template<class ContinuableFuture>
    standard_semi_future(ContinuableFuture&&);

    // get and get_expected are both destructive.
    // get will throw on exception. get_expected will return either a value
    // or an exception.
    T get() &&;
    expected<T, exception_ptr> get_expected() noexcept &&;

    // Wait is not destructive.
    standard_semi_future& wait() noexcept &;
    standard_semi_future&& wait() noexcept &&;

    bool is_ready() noexcept;

    template<class EI, class EO>
    // Where EI and EO are  one-way or two-way executors.
    // EO must be derived from EI through the executor
    // requirement API.
    standard_continuable_future<T, EO> on(EI);
};
```


Type: <code>std::standard_continuable_future</code>
========================================

```c++
template<class T, class E>
class standard_continuable_future {
public:
    using value_type = T;
    using executor_type = Ex;
    using semi_future_type = standard_semi_future<T>;

    standard_continuable_future(const standard_continuable_future&) = delete;
    standard_continuable_future(standard_continuable_future&&) = default;

    template<class ReturnFuture, class F>
    // Where ReturnFuture will satisfy the requirements of ContinuableFuture,
    // where is_same_t<ReturnFuture::value_type, result_of_t<decay_t<F>(decay_t<T>)>>
    // and will either be an instance of standard_continuable_future or
    // executor_future_t<EO, T> where EO has the same executor properties as
    // E but with the addition of the twoway_t property.
    ReturnFuture then(F&&) &&;

    template<class ReturnFuture, class F, class ResultFactory, class SharedFactory>
    // Where ReturnFuture will satisfy the requirements of ContinuableFuture,
    // where is_same_t<ReturnFuture::value_type, result_of_t<decay_t<ResultFactory>>
    // and will either be an instance of standard_continuable_future or
    // executor_future_t<EO, T> where EO has the same executor properties as
    // E but with the addition of the twoway_t property.
    ReturnFuture bulk_then(F&&, executor_shape_t<Ex>, SharedFactory&&, ResultFactory&&) &&;

    standard_continuable_future then_error(F&&) &&;

    template<class EI, class EO>
    // Where EI and EO are  one-way or two-way executors.
    // EO must be derived from EI through the executor
    // requirement API.
    standard_continuable_future<T, EO> on(EI);

    E get_executor() const;
    standard_semi_future<T> semi() &&;
}
};
```

TODO
====

- Remove this section
- Return types of continuations.
- Split above into detail sections for comments.
