<pre class='metadata'>
Title: A Unified Futures Proposal for C++
Abstract: Proposed future concepts that compose with executors.
Shortname: P1054
URL: wg21.link/P1054
Revision: 0
Audience: SG1
Status: D
Group: WG21
!Source: <a href="https://github.com/executors/futures/blob/master/futures.bs">github.com/executors/futures/blob/master/futures.bs</a>
No Abstract: yes
Markup Shorthands: markdown yes
Markup Shorthands: biblio yes
Editor: Lee Howes, Facebook, lwh@fb.com
Editor: Bryce Adelstein Lelbach, NVIDIA, brycelelbach@gmail.com
Editor: David S. Hollman, Sandia National Labs, dshollm@sandia.gov
</pre>

<!-- Keep this alphabetical by last name -->

Contributors:

* Micha≈Ç  Dominiak
* Carter  Edwards
* Jay     Feldblum
* Andrii  Grynenko
* Jared   Hoberock
* Hartmut Kaiser
* Chris   Kohlhoff
* Chris   Mysen
* Sean    Parent
* Felix   Petriconi 
* Mathias Stearn

Introduction {#intro}
=====================

TODO

Proposed New Wording
====================

Futures
-------

1.  A <dfn>future</dfn> is an object that represents a value that may not available yet.

2.  A [=future=] consists of two components: content and status.

3.  A <dfn data-lt="future's content|future content">future's content</dfn> is either a value or error.

4.  A <dfn data-lt="future's status|future status">future's status</dfn> is either [=not ready=], [=ready=] or [=consumed=].

5.  A <dfn data-lt="not ready|not ready future">not ready future</dfn> is a future whose content is not available yet.

6.  A not ready future may be <dfn data-lt="made ready|make ready">made ready</dfn>, an operation that atomically sets the [=future's content=] and changes [=future's status|its status=] to [=ready=].

7.  A <dfn data-lt="ready|ready future">ready future</dfn> is a future whose content is available.

8.  A <dfn data-lt="valid|valid future">valid future</dfn> is a future whose [=future content|content=] is available or may become available.

9.  A [=ready future=] may be <dfn data-lt="made invalid|make invalid">made invalid</dfn>, an operation that atomically invalidates the [=future's content=] and changes [=future's status|its status=] to [=invalid=].

10.  A <dfn data-lt="invalid|invalid future">invalid future</dfn> is a future whose [=future content|content=] was available previously and is now unavailable, or for which [=future content|content=] can never become available.

11. A program has undefined behavior if it accesses the [=future content|content=] of a [=not ready=] or [=invalid future=].

`FutureContinuation` Requirements
---------------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

```
namespace std {

struct exception_arg_t { explicit exception_arg_t() = default; };

inline constexpr exception_arg_t exception_arg{};

template <typename F, typename T>
  struct is_future_value_continuation;

template <typename F, typename T>
  inline constexpr bool is_future_value_continuation_v
    = is_future_value_continuation<F, T>::value;

template <typename F, typename T>
  struct is_future_exception_continuation;

template <typename F, typename T>
  inline constexpr bool is_future_exception_continuation_v
    = is_future_exception_continuation<F, T>::value;

}
```

1.  A <dfn>future continuation</dfn> is a <a href="eel.is/c++draft/func.def">callable object</a> that consumes the value of a [=future=].

<!-- Based on [optional.nullopt] p1 -->
2. The struct `exception_arg_t` is an empty structure type used as a unique type to disambiguate `FutureContinuation` overloads that are called when a [=future=]'s [=shared state=] holds an exception from `FutureContinuation` overloads that are called when a [=future=]'s [=shared state=] holds a value.

<!-- Based on [meta.rel] -->
3.  This sub-clause contains templates that may be used to determine at compile time whether a type meets the requirements of [=future continuations=] for a particular [=future=] value type. Each of these templates is a <a href="http://eel.is/c++draft/meta.rqmts#def:BinaryTypeTraith">`BinaryTypeTrait`</a> with a base characteristic of `true_type` if the corresponding condition is true and `false` otherwise.

4.  A `FutureContinuation` type shall meet the `MoveConstructible` requirements and the requirements described in the Tables below.

<center>

**Type Property Queries**

<table border=1>
<tr>
  <th>Template</th>
  <th>Condition</th>
  <th>Preconditions</th>
</tr>
<tr>
  <td>
```
template <typename F, typename T>
struct is_future_value_continuation;
```
  </td>
  <td>`is_move_constructible_v<F> && is_invocable_v<F, T>`</td>
  <td>`T` is a complete type.</td>
</tr>
<tr>
  <td>
```
template <typename F, typename T>
struct is_future_exception_continuation;
```
  </td>
  <td>`is_future_value_continuation_v<F, T> && is_invocable_v<F, T>`</td>
  <td>`T` is a complete type.</td>
</tr>
</table>

</center>

`SemiFuture` Requirements
-------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

1. A <dfn>semi future</dfn> is an object that can be bound to an executor to produce a [=future=].

2. A `SemiFuture` type for type `T` shall meet the `MoveConstructible` requirements, the `MoveAssignable` requirements, and the requirements described in the Tables below.

<center>

**Descriptive Variable Definitions**

<table border=1>
<tr>
  <th>Variable</th>
  <th>Definition</th>
</tr>
<tr>
  <td>`T`</td>
  <td>
    Either:
    * Any (possibly cv-qualified) object type that is not an array, or
    * (possibly cv-qualified) `void`.
  </td>
</tr>
<tr>
  <td>`SF<T>`</td>
  <td>A `SemiFuture` type for value type `T`.</td>
</tr>
<tr>
  <td>`sf`</td>
  <td>An rvalue of type `SF<T>`.</td>
</tr>
<tr>
  <td>`E`</td>
  <td>
    An executor type, either:
     * A `ThenExecutor` such that `promise_contract_t<T>::static_query_v<E> == true`, or
     * An `OneWayExecutor` otherwise.
  </td>
</tr>
<tr>
  <td>`e`</td>
  <td>A value of type `E`.</td>
</tr>
<tr>
  <td>`CF<T, E>`</td>
  <td>
    A `ContinuableFuture` type for value type `T` and executor type `E`, either:
    * `decltype(e.get_promise<T>().second)` if `E` is a `ThenExecutor` and `promise_contract_t<T>::static_query_v<E> == true`, or
    * `continuable_future<T>` otherwise.
  </td>
</tr>
</table>

<b>`SemiFuture` Requirements</b>

<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Operational Semantics</th>
</tr>
<tr>
  <td>`future_value_t<SF<T>>`</td>
  <td>`T`</td>
  <td></td>
</tr>
<tr>
  <td>`future_exception_t<SF<T>>`</td>
  <td>Implicitly convertible to `exception_ptr`.</td>
  <td></td>
</tr>
<tr>
  <td>`sf.via(e)`</td>
  <td>*implementation-defined*</td>
  <td>
    **Returns:** A `ContinuableFuture` for value type `T` that is bound to the executor `e` and will be made ready with the content of `sf` when `sf` is made ready.

    <!-- The compile-time requirements are captured by the description of the type `E` in the descriptive variable table -->

    **Throws:** If `!execution::query(e, promise_contract_t<T>).second`, throws any exception thrown by `!execution::query(e, oneway_t)`.
  </td>
</tr>
</table>

</center>

`ContinuableFuture` Requirements
--------------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

1. A <dfn>continuable future</dfn> is a [=future=] that is bound to an executor and can have continuations attached to it.

2. A `ContinuableFuture` shall meet the `SemiFuture` requirements and the requirements described in the Tables below.

<center>

Descriptive Variable Definitions

<table border=1>
<tr>
  <th>Variable</th>
  <th>Definition</th>
</tr>
<tr>
  <td>`E`</td>
  <td>An executor type.</td>
</tr>
<tr>
  <td>`e`</td>
  <td>A value of type `E`.</td>
</tr>
<tr>
  <td>`T`</td>
  <td>
    Either:
    * Any (possibly cv-qualified) object type that is not an array, or
    * (possibly cv-qualified) `void`.
  </td>
</tr>
<tr>
  <td>`CF<E, T>`</td>
  <td>A `ContinuableFuture` type for executor type `E` and value type `T`.</td>
</tr>
<tr>
  <td>`cf`</td>
  <td>A value of type `CF<E, T>`.</td>
</tr>
<tr>
  <td>`rcf`</td>
  <td>An rvalue of type `CF<E, T>`.</td>
</tr>
<tr>
  <td>`SF<T>`</td>
  <td>A `SemiFuture` type for value type `T`.</td>
</tr>
<tr>
  <td>`G`</td>
  <td>Any type such that `is_future_continuation_v<G, T> == true`.</td>
</tr>
<tr>
  <td>`g`</td>
  <td>An object of type `G`.</td>
</tr>
<tr>
 <td>`val`</td>
 <td>The value contained within the successfully completed future `rcf`.</td>
</tr>
<tr>
 <td>`ex`</td>
 <td>The exception contained within the exceptionally completed future `rcf`.</td>
</tr>
<tr>
  <td>`NORMAL`</td>
  <td>
    Either:
    * `DECAY_COPY(std::forward<F>(g))()` if `is_same_v<remove_cv_t<T>, void>`, and
    * `DECAY_COPY(std::forward<F>(g))(std::move(val))` otherwise.
  </td>
</tr>
<tr>
  <td>`EXCEPTIONAL`</td>
  <td>
    The expression `DECAY_COPY(std::forward<F>(f))(exception_arg, std::move(ex))`.
  </td>
</tr>
</table>

`ContinuableFuture` Requirements

<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Operational Semantics</th>
</tr>
<tr>
  <td>`cf.get_executor()`</td>
  <td>`E`</td>
  <td>
    **Returns:** The executor that the future is bound to.

    **Throws:** Nothing.
  </td>
</tr>
<tr>
  <td>`rcf.then(g)`</td>
  <td>
    **If** `T` is non-void and `INVOKE(declval<G>(), declval<T>())` or if `T` is
      `void` and `INVOKE(declval<G>())` is valid:

      `CF<E, decltype(INVOKE(declval<G>(), declval<T>()))>`

    **Otherwise**:

      `CF<E, T>`
  </td>
  <td>
    **Returns:** A `ContinuableFuture` that is bound to the executor `e` and
    that wraps the type returned by execution of either the value or exception
    operations implemented in the continuation.

    **Effects:**
      When `rcf` becomes nonexceptionally ready, and if `NORMAL` is a
      well-formed expression, creates an execution agent which invokes `NORMAL`
      at most once, with the call to `DECAY_COPY` being evaluated in the thread
      that called `.then`.

      Otherwise, when `rcf` becomes exceptionally ready, if `EXCEPTIONAL` is a
      well-formed expression, creates an execution agent which invokes
      `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
      in the thread that called `.then`.

      If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
      `decltype(EXCEPTIONAL)` shall be convertible to `R`.

      If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
      well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
      `decltype(val)`.

      If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
      invocation of `.then` shall be ill-formed.

      May block pending completion of `NORMAL` or `EXCEPTIONAL`.

      The invocation of `.then` synchronizes with
      (C++Std [intro.multithread]) the invocation of `f`.

      Stores the result of either the `NORMAL` or `EXCEPTIONAL` expression, or
      any exception thrown by either, in the associated shared state of the
      resulting `ContinuableFuture`. Otherwise, stores either `val` or `e` in
      the associated shared state of the resulting `ContinuableFuture`.

    **Synchronization:** The destruction of the continuation that generates
      `rcf`'s value synchronizes-with the start of `g` and with the destruction
      of `g`.
  </td>
</tr>
<tr>
  <td>`rcf.semi()`</td>
  <td>
    `SF<T>`
  </td>
  <td>
    **Returns:** A `SemiFuture` that completes when `rcf` would have completed.

    **Effects:** Erasing the executor from `rcf`.
  </td>
</tr>
</table>

</center>


`SharedFuture` Requirements
--------------------------------

<!-- Based on [container.requirements], [utility.arg.requirements], [thread.req.lockable], and [allocator.requirements] -->

1. A <dfn>shared future</dfn> is a [=future=] that is copyable, is bound to an executor and that allows one or more continuation to be attached to it.

2. A `SharedFuture` shall meet the `ContinuableFuture` requirements, the `CopyConstructible` requirements, the `CopyAssignable` requirements and the requirements described in the Tables below.

<center>

Descriptive Variable Definitions

<table border=1>
<tr>
  <th>Variable</th>
  <th>Definition</th>
</tr>
<tr>
  <td>`E`</td>
  <td>An executor type.</td>
</tr>
<tr>
  <td>`e`</td>
  <td>A value of type `E`.</td>
</tr>
<tr>
  <td>`T`</td>
  <td>Any (possibly cv-qualified) object type that is not an array.</td>
</tr>
<tr>
  <td>`SHF<E, T>`</td>
  <td>A `SharedFuture` type for executor type `E` and value type `T`.</td>
</tr>
<tr>
  <td>`shf`</td>
  <td>A value of type `CF<E, F>`.</td>
</tr>
<tr>
  <td>`NORMAL`</td>
  <td>
    The expression `DECAY_COPY(std::forward<F>(g))(val)` if
    `T` is non-void and `DECAY_COPY(std::forward<F>(g))()` if `T` is void,
  </td>
</tr>
<tr>
  <td>`EXCEPTIONAL`</td>
  <td>
    The expression
    `DECAY_COPY(std::forward<F>(f))(exception_arg, ex)`,
  </td>
</tr>
</table>

`SharedFuture` Requirements

<table border=1>
<tr>
  <th>Expression</th>
  <th>Return Type</th>
  <th>Operational Semantics</th>
</tr>
<tr>
  <td>`shf.then(g)`</td>
  <td>
    **If** `T` is non-void and `INVOKE(declval<G>(), declval<T>())` or if `T` is
      `void` and `INVOKE(declval<G>())` is valid:

      `CF<E, decltype(INVOKE(declval<G>(), declval<T>()))>`

    **Otherwise**:

      `CF<E, T>`
  </td>
  <td>
    **Returns:** A `ContinuableFuture` that is bound to the executor `e` and
    that wraps the type returned by execution of either the value or exception
    operations implemented in the continuation.

    **Effects:**
      When `shf` becomes nonexceptionally ready, and if `NORMAL` is a
      well-formed expression, creates an execution agent which invokes `NORMAL`
      at most once, with the call to `DECAY_COPY` being evaluated in the thread
      that called `.then`.

      Otherwise, when `shf` becomes exceptionally ready, if `EXCEPTIONAL` is a
      well-formed expression, creates an execution agent which invokes
      `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
      in the thread that called `.then`.

      If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
      `decltype(EXCEPTIONAL)` shall be convertible to `R`.

      If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
      well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
      `decltype(val)`.

      If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
      invocation of `.then` shall be ill-formed.

      May block pending completion of `NORMAL` or `EXCEPTIONAL`.

      The invocation of `.then` synchronizes with
      (C++Std [intro.multithread]) the invocation of `f`.

      Stores the result of either the `NORMAL` or `EXCEPTIONAL` expression, or
      any exception thrown by either, in the associated shared state of the
      resulting `ContinuableFuture`. Otherwise, stores either `val` or `e` in
      the associated shared state of the resulting `ContinuableFuture`.

    **Postconditions:** Has no observable affect on `sfh`.
  </td>
</tr>
<tr>
  <td>`shf.via(e)`</td>
  <td>Implementation-defined</td>
  <td>
    **Returns:** A `ContinuableFuture` for type `T` that is bound to the executor `e`.

    **Effect:** Returns an implementation-defined `ContinuableFuture` onto which continuations can be attached that will run on `e`.

    **Success:** Succeeds if:
     * `e` is a `ThenExecutor` where `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)` is valid.
     * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

     Fails at compile-time otherwise.


    **Postconditions:** Has no observable affect on `sfh`.
  </td>
</tr>
</table>

</center>

`std::standard_promise`
-----------------------

```
template<class T>
class standard_promise {
public:
    using promise_default_executor = implementation-defined;

    standard_continuable_future<T, promise_default_executor>
      get_continuable_future();

    standard_semi_future<T> get_semi_future();

    template<class Value>
    void set_value(Value&& val);

    template<class Error = std::exception_ptr>
    void set_exception(Error&& val);
};
```

The default executor type for promises allows for efficient promise->future
code. This executor is intended for use only locally. It may be optimised
using thread-local storage and should not be constructible. It is not copyable
and its lifetime is not guaranteed to outlive a single continuation chain
starting with a promise.

<br/>
```
standard_future<T, promise_default_executor> get_continuable_future();
```

* *Effects:* Obtained a `standard_continuable_future` that completes on the
    promise's default executor when `this->set_value(v)` or
    `this->set_exception(e)` is called.

* *Postconditions:* Further calls to `get_continuable_future()` or
    to `get_semi_future()` will throw.

<br/>
```
template<class Value>
void set_value(Value&& val);
```
 * *Requires:* The result of `std::decay_t<Value>` is `T`.

 * *Effects:* Completes the associated future with value `val`.

 * *Postconditions:* Further calls to `set_value` or `set_exception` may throw.

<br/>
```
template<class Error = std::exception_ptr>
void set_exception(Error&& ex);
```

 * *Requires:* The result of `std::decay_t<Error>` is `std::exception_ptr`.

 * *Effects:* Completes the associated future with exception `ex`.

 * *Postconditions:* Further calls to `set_value` or `set_exception` may throw.



`std::standard_semi_future`
---------------------------

```
template<class T>
class standard_semi_future {
public:
    using value_type = T;

    // StandardSemiFuture may be constructed already complete
    standard_semi_future(standard_semi_future&&) = default;
    standard_semi_future(const standard_semi_future&) = delete;

    standard_semi_future& operator=(const standard_semi_future&) = delete;
    standard_semi_future& operator=(standard_semi_future&&) = default;

    template<class E>
    explicit standard_semi_future(standard_continuable_future<T, E>&&);

    template<class E>
    explicit standard_semi_future(standard_shared_future<T, E>&&);

    template<class EI, class EO>
    // Where EI and EO are  one-way or two-way executors.
    // EO must be derived from EI through the executor
    // requirement API.
    standard_continuable_future<T, EO> via(EI) &&;
};
```

<br/>
```
standard_continuable_future(standard_semi_future&& rhs);
```

 * *Effects:*  Move constructs a future object that refers to the shared state
    that was originally referred to by rhs (if any).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
     * rhs.valid() == false.

<br/>
```
standard_semi_future(const standard_semi_future& rhs);
```

 * *Effects:* Copy constructs a future object that refers to the shared state
    that was originally referred to by rhs (if any).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the
    constructor invocation. The validity of rhs does not change.

<br/>
```
template<class E>
standard_semi_future(standard_continuable_future<T, E>&& rhs);
```

* *Effects:* Move constructs a future object that refers to the shared state that
    was originally referred to by rhs (if any).

* *Postconditions:*
   * valid() returns the same value as rhs.valid() prior to the constructor invocation.
   * rhs.valid() == false.


<br/>
```
template<class E>
explicit standard_semi_future(standard_shared_future<T, E>&& rhs);

template<class E>
explicit standard_semi_future(const standard_shared_future<T, E>& rhs);
```

 * *Effects:* Move constructs a future object that refers to the shared state
    that was originally referred to by rhs (if any).

 * *Postconditions:*
    * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
    * rhs.valid() == false.

<br/>
```
standard_continuable_future<T, EI> via(EI ex) &&;
```

 * *Effects:* Returns a new future that will complete when this completes but
    on which continuations will be enqueued to a new executor.

 * *Returns:* A standard_continuable_future modified to carry executor ex of
    type EI.

 * *Requires:*
   * `e` is a `ThenExecutor` where
     `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or
     `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)`
     is valid.
   * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

 * *Postconditions:* valid() == false.

<br/>
```
bool valid() const noexcept;
```

 * *Returns:* Returns true if this is a valid future. False otherwise.

`std::standard_continuable_future`
----------------------------------

```
template<class T, class E>
class standard_continuable_future {
public:
    using value_type = T;
    using executor_type = Ex;
    using semi_future_type = standard_semi_future<T>;

    standard_continuable_future(const standard_continuable_future&) = delete;
    standard_continuable_future(standard_continuable_future&&) = default;

    standard_continuable_future& operator=(const standard_continuable_future&) = delete;
    standard_continuable_future& operator=(standard_continuable_future&&) = default;

    template<class E>
    explicit standard_continuable_future(standard_shared_future<T, E>&&);
    template<class E>
    explicit standard_continuable_future(const standard_shared_future<T, E>&);

    template<class ReturnFuture, class F>
    // Where ReturnFuture will satisfy the requirements of ContinuableFuture,
    // where is_same_t<ReturnFuture::value_type, result_of_t<decay_t<F>(decay_t<T>)>>
    // and will either be an instance of standard_continuable_future or
    // executor_future_t<EO, T> where EO has the same executor properties as
    // E but with the addition of the twoway_t property.
    ReturnFuture then(FutureContinuation&&) &&;

    template<class EI, class EO>
    // Where EI and EO are  one-way or two-way executors.
    // EO must be derived from EI through the executor
    // requirement API.
    standard_continuable_future<T, EO> via(EI) &&;

    E get_executor() const;
    standard_semi_future<T> semi() &&;
    standard_shared_future<T, E> share() &&;

    bool valid() const
}
};
```

<br/>
```
standard_continuable_future(standard_continuable_future&& rhs);
```

 * *Effects:*  Move constructs a future object that refers to the shared state
    that was originally referred to by rhs (if any).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
     * rhs.valid() == false.

<br/>
```
standard_continuable_future(const standard_continuable_future& rhs);
```

 * *Effects:* Copy constructs a future object that refers to the shared state
    that was originally referred to by rhs (if any).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the
    constructor invocation. The validity of rhs does not change.

<br/>
```
template<class E>
explicit standard_continuable_future(standard_shared_future<T, E>&& rhs);

template<class E>
explicit standard_continuable_future(const standard_shared_future<T, E>& rhs);
```

 * *Effects:* Move constructs a future object that refers to the shared state that
    was originally referred to by rhs (if any).

 * *Postconditions:*
    * valid() returns the same value as rhs.valid() prior to the constructor
        invocation.
    * rhs.valid() == false.

<br/>
```
template<class ReturnFuture, class F>
ReturnFuture then(F&&) &&;
```

 * *Requires:*
    F satisfies the requirements of FutureContinuation.

 * *Returns:* A `ContinuableFuture` that is bound to the executor `e` and
    that wraps the type returned by execution of either the value or exception
    operations implemented in the continuation. The type of the returned
    `ContinuableFuture` is defined by `Executor` `E`.

 * *Effects:*
     * For `NORMAL` defined as the expression `DECAY_COPY(std::forward<F>(g))(val)` if
        `T` is non-void and `DECAY_COPY(std::forward<F>(g))()` if `T` is void.

     * For `EXCEPTIONAL` defined as the expression
        `DECAY_COPY(std::forward<F>(f))(exception_arg, ex)`,

     * When `*this` becomes nonexceptionally ready, and if `NORMAL` is a
        well-formed expression, creates an execution agent which invokes `NORMAL`
        at most once, with the call to `DECAY_COPY` being evaluated in the thread
        that called `.then`.

     * Otherwise, when `*this` becomes exceptionally ready, if `EXCEPTIONAL` is a
        well-formed expression, creates an execution agent which invokes
        `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
        in the thread that called `.then`.

     * If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
        `decltype(EXCEPTIONAL)` shall be convertible to `R`.

     * If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
        well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
        `decltype(val)`.

     * If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
        invocation of `.then` shall be ill-formed.

     * May block pending completion of `NORMAL` or `EXCEPTIONAL`.

     * The invocation of `.then` synchronizes with
        (C++Std [intro.multithread]) the invocation of `f`.

     * Stores the result of either the `NORMAL` or `EXCEPTIONAL` expression, or
        any exception thrown by either, in the associated shared state of the
        resulting `ContinuableFuture`. Otherwise, stores either `val` or `e` in
        the associated shared state of the resulting `ContinuableFuture`.

 * *Postconditions:* valid() == false.

<br/>
```
standard_continuable_future<T, EI> via(EI ex) &&;
```

 * *Effects:* Returns a new future that will complete when this completes but
    on which continuations will be enqueued to a new executor.

 * *Returns:* A standard_continuable_future modified to carry executor ex of
    type EI.

 * *Requires:*
   * `e` is a `ThenExecutor` where
      `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or
      `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)`
      is valid.
   * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

  * *Postconditions:* valid() == false.

<br/>
```
E get_executor() const;
```
 * *Returns:* If is_valid() returns true returns the executor contained within the
    future. Otherwise throws std::future_error.

<br/>
```
standard_semi_future<T> semi() &&;
```
 * *Returns:*
    Returns a standard_semi_future of the same value type as \*this and that
    completes when this completes, but that erases the executor. is_valid() on the
    returned standard_semi_future will return the same value as is_valid() on
    \*this.

<br/>
```
bool valid() const noexcept;
```

 * *Returns:* Returns true if this is a valid future. False otherwise.

<br/>
```
standard_shared_future<T, E> share() &&;
```

 * *Returns:* standard_shared_future<R>(std::move(\*this)).

 * *Postconditions:* valid() == false.





`std::standard_shared_future`
----------------------------------

```
namespace std {
  template<class T, class E>
  class standard_shared_future {
  public:
      using value_type = T;
      using executor_type = Ex;
      using semi_future_type = standard_semi_future<T>;

      standard_shared_future(const standard_shared_future&) = default;
      standard_shared_future(standard_shared_future&&) = default;

      standard_shared_future& operator=(const standard_shared_future&) = default
      standard_shared_future& operator=(standard_shared_future&&) = default;

      template<class E>
      explicit standard_shared_future(standard_continuable_future<T, E>&&);

      template<class ReturnFuture, class F>
      ReturnFuture then(FutureContinuation&&);

      template<class EI>
      standard_shared_future<T, EI> via(EI);

      E get_executor() const;
      standard_semi_future<T> semi();

      bool valid() const;
  }
  };
}
```

<br/>
```
standard_shared_future(standard_shared_future&& rhs);
```

 * *Effects:*  Move constructs a future object that refers to the shared state that
      was originally referred to by rhs (if any).

 * *Postconditions:*
     * valid() returns the same value as rhs.valid() prior to the constructor invocation.
     * rhs.valid() == false.

<br/>
```
standard_shared_future(const standard_shared_future& rhs);
```

 * *Effects:* Copy constructs a future object that refers to the shared state that was originally referred to by rhs (if any).

 * *Postconditions:* valid() returns the same value as rhs.valid() prior to the constructor invocation. The validity of rhs does not change.

<br/>
```
explicit standard_shared_future(standard_continuable_future&& rhs);
```

 * *Effects:* Move constructs a future object that refers to the shared state that
      was originally referred to by rhs (if any).

 * *Postconditions:*
    * valid() returns the same value as rhs.valid() prior to the constructor invocation.
    * rhs.valid() == false.

<br/>
```
template<class ReturnFuture, class F>
ReturnFuture then(F&&);
```

 * *Requires:* F satisfies the requirements of FutureContinuation.

 * *Returns:* A `ContinuableFuture` that is bound to the executor `e` and
      that wraps the type returned by execution of either the value or exception
      operations implemented in the continuation. The type of the returned
      `ContinuableFuture` is defined by `Executor` `E`.

 * *Effects:*
     * For `NORMAL` defined as the expression `DECAY_COPY(std::forward<F>(g))(val)` if
        `T` is non-void and `DECAY_COPY(std::forward<F>(g))()` if `T` is void.

     * For `EXCEPTIONAL` defined as the expression
        `DECAY_COPY(std::forward<F>(f))(exception_arg, ex)`,

     * When `*this` becomes nonexceptionally ready, and if `NORMAL` is a
        well-formed expression, creates an execution agent which invokes `NORMAL`
        at most once, with the call to `DECAY_COPY` being evaluated in the thread
        that called `.then`.

     * Otherwise, when `*this` becomes exceptionally ready, if `EXCEPTIONAL` is a
        well-formed expression, creates an execution agent which invokes
        `EXCEPTIONAL` at most once, with the call to `DECAY_COPY` being evaluated
        in the thread that called `.then`.

     * If `NORMAL` and `EXCEPTIONAL` are both well-formed expressions,
        `decltype(EXCEPTIONAL)` shall be convertible to `R`.

     * If `NORMAL` is not a well-formed expression and `EXCEPTIONAL` is a
        well-formed expression, `decltype(EXCEPTIONAL)` shall be convertible to
        `decltype(val)`.

     * If neither `NORMAL` nor `EXCEPTIONAL` are well-formed expressions, the
        invocation of `.then` shall be ill-formed.

     * May block pending completion of `NORMAL` or `EXCEPTIONAL`.

     * The invocation of `.then` synchronizes with
        (C++Std [intro.multithread]) the invocation of `f`.

     * Stores the result of either the `NORMAL` or `EXCEPTIONAL` expression, or
        any exception thrown by either, in the associated shared state of the
        resulting `ContinuableFuture`. Otherwise, stores either `val` or `e` in
        the associated shared state of the resulting `ContinuableFuture`.

 * *Postconditions:* No observable change to \*this.


<br/>
```
standard_shared_future<T, EI> via(EI ex);
```

 * *Effects:* Returns a new future that will complete when this completes but
      on which continuations will be enqueued to a new executor.

 * *Returns:* A standard_shared_future modified to carry executor ex of type EI.

 * *Requires:*
   * `e` is a `ThenExecutor` where `INVOKE(e, [](T){}, execution::query(e, promise_contract_t<T>).second)` or `INVOKE(e, [](T&){}, execution::query(e, promise_contract_t<T>).second)` is valid.
   * `e` is a `OnewayExecutor` or is convertible to a OnewayExecutor.

 * *Postconditions:* No observable change to \*this.

 <br/>
```
E get_executor() const;
```
 * *Returns:* If is_valid() returns true returns the executor contained within the
    future. Otherwise throws std::future_error.

<br/>
```
standard_semi_future<T> semi();
```
 * *Returns:*
      Returns a standard_semi_future of the same value type as \*this and that
      completes when this completes, but that erases the executor. is_valid() on the
      returned standard_semi_future will return the same value as is_valid() on
      \*this.

<br/>
```
bool valid() const noexcept;
```
 * *Returns:* Returns true if this is a valid future. False otherwise.


`std::this_thread::future_wait`
----------------------------------
In [thread.syn] and [thread.thread.this] extend `this_thread` namespace:
```
template<class Future>
  void future_wait(Future& f) noexcept;
```

<br/>
To [thread.thread.this] add:
```
template<class Future>
  void std::this_thread::future_wait(Future& f) noexcept;
```

 * *Requires:* SemiFuture<Future>

 * *Effects:* Blocks the calling thread until `f` becomes ready.

 * *Synchronization:* The destruction of the continuation that generates `f`'s
      value synchronizes-with the corresponding `future_wait` return.

<br/>
`std::this_thread::future_get`
----------------------------------
In [thread.syn] and [thread.thread.this] extend `this_thread` namespace:
```
template<class Future>
  auto future_get(Future& f) -> Future::value_type;
```

<br/>
To [thread.thread.this] add:
```
template<class Future>
  auto std::this_thread::future_get(std::decay_t<Future>&& f)
    -> std::decay_t<Future>::value_type;
```
 * *Requires:* SemiFuture<Future>

 * *Effects:* Blocks the calling thread until `f` becomes ready.

 * *Returns:*
     * If `f` becomes ready with a value, moves the value from `f` and returns it
        to the caller.
     * If `f` becomes ready with an exception, rethrows the exception.

 * *Synchronization:* The destruction of the continuation that generates `f`'s
      value synchronizes-with the corresponding `future_get` return.

 * *Throws:* If `f` becomes ready with an exception, that exception is rethrown.

Proposed Addition to Executors P0443
=============================

[p0443](https://wg21.link/P0443) defines a collection of executor types intended
for use managing the execution of tasks on resources.
There are three fundamental executor categories that cover directionality and
control of launch:
 * one-way
 * two-way
 * then

The first two could be considered *immediately launched*. That is that once
handed to the executor, they may start immediately, assuming the internal
executor policies and resources allow it. This makes them very useful for
lazy-launch scenarios.

Lazy launch scenarios are common in callback-based code, and in a wide range of
future library implementations such as
[folly](https://github.com/facebook/folly/tree/master/folly/futures).
In these designs, a callback is executed on completion of some asynchronous
work, and that callback enqueues work into the executor.
This means that work is enqueued only after all dependencies are satisfied.

Then-executors, on the other hand, are intended for explicitly deferred work.
Work can be handed to the executor dependent on prior work, before that prior
work is completed.
This design is fundamentally different, but offers scope for optimization by
the executor of chains of dependencies that it can batch, without running
additional code on completion of each.

The current executor design is intentionally generic - it makes few requirements
on the future types it can use as input dependencies for the `then_execute` and
`bulk_then_execute` operations.
We can assume that for a future returned by a previous call to `then_execute`
or `bulk_then_execute`, the executor understands the implementation of the
future can can perform whatever dependence tracking and optimization necessary.
This then is an implementation detail.

However, there will also be interactions where a task to run on one executor is dependent on one produced by another. For this to be practical, we need a standardised mechanism to tie the two executors together.
This amounts to a standard API for triggering deferred work.

Proposed solution
-------------------

To solve this we provide two things:
 * A promise concept, that allows setting of value and/or exception.
 * A mechanism to retrieve from an executor a pair of a promise and a future, such that the future is a valid input dependence for a call to `then_execute` or `bulk_then_execute`.

The promise is a write-only concept. This simplifies the definition and improves flexibility.

The future is not a full future in the sense of future concepts. It is merely a token that completes when the promise is satisfied. This means that it is useful only for connecting to `then_execute` or `bulk_then_execute` on the executor that provided the result.

Proposed New Wording
====================

Wording supplements current text in [p0443](https://wg21.link/P0443).

1.1.x `Promise` requirements
--------------------

A type `P` meets the `Promise` requirements for some value type `T` if an
instance `p` of `P` satisfies the requirements in the table below. `T` may be
void.

<table>
  <tr>
    <th>Expression</th>
    <th>Return Type</th>
    <th>Operational semantics</th>
  </tr>
  <tr>
    <td>`p.set_value(T)`</td>
    <td>void</td>
    <td>Completes the promise with a value.</td>
  </tr>
  <tr>
    <td>`p.set_exception(std::exception_ptr)`</td>
    <td>void</td>
    <td>Completes the promise with an exception wrapped in a `std::exception_ptr`.</td>
  </tr>
</table>


1.3.3.2 Promise contract
--------------------

```
template <T>
struct promise_contract_t
{
  static constexpr bool is_requirable = false;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type
    = std::pair<std::promise<T>, std::future<T>>;

  template<class Executor>
  static constexpr decltype(auto) static_query_v
    = Executor::query(promise_contract_t());
};
```

The `promise_contract_t` property can be used only with query.

The result of a query of the `promise_contract_t` property applied to a
`ThenExecutor` or `BulkThenExecutor` is a `std::pair` consisting of a `Promise`
and an implementation-defined token type that will be interpreted as a valid
input future by calls to `then_execute` or `bulk_then_execute` and that is
satisfied by calling `set_value` or `set_exception` on the promise.

The value returned from `execution::query(e, promise_contract_t<T>)`, where `e`
is an executor and `T` is a type, should be unique for any given call.
When `e` is a `ThenExecutor` or `BulkThenExecutor` the result of the query is a
`std::pair` where first value is an instance of a type matching the `Promise`
requirements and the second is a token type that `e` will interpret as a valid
future parameter to calls to `then_execute` or `bulk_then_execute`.
When `e` is neither a `ThenExecutor` nor a `BulkThenExecutor` the result of the
query is a `std::pair` where the first value is a `std::promise<T>` and the
second is a `std::future<T>` such that the future was retrieved from the
promise.


1.3.3.2 Cancellable promise contract
--------------------

```
template <T, C>
struct cancellable_promise_contract_t
{
  static constexpr bool is_requirable = false;
  static constexpr bool is_preferable = false;

  using polymorphic_query_result_type
    = std::pair<std::promise<T>, std::future<T>>;

  template<class Executor>
  static constexpr decltype(auto) static_query_v
    = Executor::query(promise_contract_t());

  CancellationCallback cancellation_callback;
};
```

The `cancellable_promise_contract_t` property can be used only with query.
`cancellable_promise_contract_t` differs from `promise_contract_t` in that the
query carries a cancellation callback, `cancellation_callback`, that will be
called as `std::invoke(cancellation_callback)` by the `ThenExecutor` on
cancellation of the task dependent on the future resulting from the
`cancellable_promise_contract_t` query.

The result of a query of the `cancellable_promise_contract_t` property applied
to a `ThenExecutor` or `BulkThenExecutor` is a `std::pair` consisting of a
`Promise` and an implementation-defined token type that will be interpreted as
a valid input future by calls to `then_execute` or `bulk_then_execute`, that
is satisfied by calling `set_value` or `set_exception` on the promise and that
supports cancellation by the executor.

The value returned from
`execution::query(e, cancellable_promise_contract_t<T>{cancellation_callback})`,
where `e` is an executor and `T` is a type, should be unique for any given call.
When `e` is a `ThenExecutor` or `BulkThenExecutor` the result of the query is a
`std::pair` where first value is an instance of a type matching the `Promise`
requirements and the second is a token type that `e` will interpret as a valid
future parameter to calls to `then_execute` or `bulk_then_execute`.
When `e` is neither a `ThenExecutor` nor a `BulkThenExecutor` the result of the
query is a `std::pair` where the first value is a `std::promise<T>` and the
second is a `std::future<T>` such that the future was retrieved from the
promise.


Proposed Modifications to Executors P0443
=============================
[p0443](https://wg21.link/P0443) currently requires `std::experimental::future`
due to the absence of a complete future type in the core standard.

This paper provides the wider set of tasks and as a result, the current text in
[p0443](https://wg21.link/P0443) should be modified as follows.


Future requirements
--------------------
Drop this entire section and replace with the `Future` requirements from this
paper.


TwoWayExecutor requirements
--------------------
In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.


In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.



ThenExecutor requirements
--------------------
In the type requirements list.

**Replace:**
 * fut denotes a future object satisfying the Future requirements,

**With:**
 * fut denotes a future object that:
     * was returned by a call to `x.twoway_execute`, `x.bulk_twoway_execute`,
        `x.then_execute`, or `x.bulk_then_execute` and meets the
        `ContinuableFuture` requirements.
     * was returned by a call to `execution::query(x, promise_contract_t<T>)` or
        `execution::query(x, cancellable_promise_contract_t<T>)`

In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.


In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.


BulkTwoWayExecutor requirements
--------------------
In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFutureFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.

In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.


BulkThenExecutor requirements
--------------------
In the type requirements list.

**Replace:**
 * fut denotes a future object satisfying the Future requirements,

**With:**
 * fut denotes a future object that:
     * was returned by a call to `x.twoway_execute`, `x.bulk_twoway_execute`,
        `x.then_execute`, or `x.bulk_then_execute` and meets the
        `ContinuableFuture` requirements.
     * was returned by a call to `execution::query(x, promise_contract_t<T>)` or
        `execution::query(x, cancellable_promise_contract_t<T>)`.

In the *Return Type* column.

**Replace:**
A type that satisfies the Future requirements for the value type R.

**With:**
A type that satisfies the ContinuableFutureFuture requirements for the value
type R and for which `returnvalue.get_executor()` returns x.


In the *Operational Semantics* column.

**Replace:**
in the associated shared state of the resulting Future.

**With:**
in the resulting ContinuableFuture.


twoway_t customization points
--------------------
**Replace:**

    it is `std::experimental::future<T>`

**with:**

    it is `std::standard_continuable_future<T, E1>` such that a call to
   `get_executor()` returns a copy of `e1`


single_t customization points
--------------------
**Replace:**

    it is `std::experimental::future<T>`

**with:**

    it is `std::standard_continuable_future<T, E1>` such that a call to
    `get_executor()` returns a copy of `e1`


Properties to indicate if blocking and directionality may be adapted
--------------------
Remove `twoway_t` from the **Requirements** column of hte table.

Remove note referring to `std::experimental::future`.

[*Note:* `std::experimental::future` is not used and the replacemnt does not
 have a blocking wait so this is no longer relevant.]


Class template executor
--------------------
**Replace:**
```
  template<class Function>
    std::experimental::future<result_of_t<decay_t<Function>()>>
      twoway_execute(Function&& f) const
```

**With:**
```
  template<class Function>
    std::standard_semi_future<result_of_t<decay_t<Function>()>>
      twoway_execute(Function&& f) const
```

**Replace:**
```
  template<class Function, class ResultFactory, class SharedFactory>
    std::experimental::future<result_of_t<decay_t<ResultFactory>()>>
      bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```

**With:**
```
  template<class Function, class ResultFactory, class SharedFactory>
    std::standard_semi_future<result_of_t<decay_t<ResultFactory>()>>
      bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```

[*Note:* We lose the executor information here. Potentially we should encode
 the future type, including its executor, in the properties of the polymorphic
 wrapper.]


executor operations
--------------------
**Replace:**

```
template<class Function>
  std::experimental::future<result_of_t<decay_t<Function>()>>
    twoway_execute(Function&& f) const
```

**With:**

```
template<class Function>
  /* implementation-defined future type */
    twoway_execute(Function&& f) con
```

**Replace:**

Returns: A future, whose shared state is made ready when the future returned by
e.twoway_execute(f2) is made ready, containing the result of f1() or any
exception thrown by f1(). [Note: e2.twoway_execute(f2) may return any future
type that satisfies the Future requirements, and not necessarily
std::experimental::future. One possible implementation approach is for the
polymorphic wrapper to attach a continuation to the inner future via that
object's then() member function. When invoked, this continuation stores the
result in the outer future's associated shared and makes that shared state
ready. --end note]

**With:**

*Returns:* A value whose type satisfies the `ContinuableFuture` requirements.
The returned future is made ready when `f1()` completes execution, with the
result of `f1()` if `decltype(f1())` is non-void, void completion if
`decltype(f1())` is void or any exception thrown by `f1()`.


**Replace:**

template<class Function, class ResultFactory, class SharedFactory>
  std::experimental::future<result_of_t<decay_t<ResultFactory>()>>
    void bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;


**With:**
```
template<class Function, class ResultFactory, class SharedFactory>
  /* implementation-defined future type */
     bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```


**Replace:**

*Returns:* A future, whose shared state is made ready when the future returned
by e.bulk_twoway_execute(f2, n, rf2, sf2) is made ready, containing the result
in r1 (if decltype(rf1()) is non-void) or any exception thrown by an
invocationf1. [Note: e.bulk_twoway_execute(f2) may greturn any future type that
satisfies the Future requirements, and not necessarily std::experimental::future.
One possible implementation approach is for the polymorphic wrapper to attach a
continuation to the inner future via that object's then() member function. When
invoked, this continuation stores the result in the outer future's associated
shared and makes that shared state ready. --end note]

**With:**

*Returns:* A value whose type satisfies the `ContinuableFuture` requirements.
The returned future is made ready when `f1()` completes execution, with
the result in `r1` (if `decltype(rf1())` is non-void), valueless completion
(if `decltype(rf1())` is void) or any exception thrown by an invocation `f1`.


static_thread_pool executor types
--------------------
**Replace:**
```
    template<class Function>
      std::experimental::future<result_of_t<decay_t<Function>()>>
        twoway_execute(Function&& f) const

    template<class Function, class Future>
      std::experimental::future<result_of_t<decay_t<Function>(decay_t<Future>)>>
        then_execute(Function&& f, Future&& pred) const;

    template<class Function, class SharedFactory>
      void bulk_execute(Function&& f, size_t n, SharedFactory&& sf) const;

    template<class Function, class ResultFactory, class SharedFactory>
      std::experimental::future<result_of_t<decay_t<ResultFactory>()>>
        void bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const;
```

**With:**
```
  template<class Function>
    std::standard_continuable_future<result_of_t<decay_t<Function>()>, C>
      twoway_execute(Function&& f) const

  template<class Function, class Future>
    std::standard_continuable_future<result_of_t<decay_t<Function>(decay_t<Future>)>, C>
      then_execute(Function&& f, Future&& pred) const;

  template<class Function, class SharedFactory>
    void bulk_execute(Function&& f, size_t n, SharedFactory&& sf) const;

  template<class Function, class ResultFactory, class SharedFactory>
    std::standard_continuable_future<result_of_t<decay_t<ResultFactory>()>>, C>
      void bulk_twoway_execute(Function&& f, size_t n, ResultFactory&& rf, SharedFactory&& sf) const
```

Replace the same instances in the documentation section below the main code
block.
